<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[neeko의 개발 블로그입니다.]]></description><link>https://yeaseul7.github.io/neekoblog</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 06 Mar 2025 12:38:03 GMT</lastBuildDate><item><title><![CDATA[RequestAnimationFrame]]></title><link>https://yeaseul7.github.io/neekoblog/requestAnimationFrame/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/requestAnimationFrame/</guid><pubDate>Thu, 06 Mar 2025 21:00:56 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[LLM에 대해 알아보기]]></title><description><![CDATA[LLM이란? LLM은 대화형 인공지능 모델이다. 더 자세히 말하면 LLM은 언어를 이해하고 생성하기 위해 많은 데이터를 소비할 수 있는 딥 러닝 알고리즘이다. LLM은 신경망 아키텍처를 사용하여 언어 모델링을 수행하는 딥 러닝 모델이다. LLM…]]></description><link>https://yeaseul7.github.io/neekoblog/aboutLLM/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/aboutLLM/</guid><pubDate>Sun, 09 Feb 2025 15:40:56 GMT</pubDate><content:encoded>&lt;h3&gt;LLM이란?&lt;/h3&gt;
&lt;p&gt;LLM은 대화형 인공지능 모델이다.&lt;/p&gt;
&lt;p&gt;더 자세히 말하면 LLM은 언어를 이해하고 생성하기 위해 많은 데이터를 소비할 수 있는 딥 러닝 알고리즘이다.&lt;/p&gt;
&lt;p&gt;LLM은 신경망 아키텍처를 사용하여 언어 모델링을 수행하는 딥 러닝 모델이다.&lt;/p&gt;
&lt;h3&gt;LLM의 특징&lt;/h3&gt;
&lt;p&gt;LLM은 transformer modal을 이용한다.
이것은 LLM의 일반적인 아키텍처이다. 이것은 인코더와 디코더로 구성된다.
이 모델은 input을 토큰화 하고 그 토큰과의 관계를 수학적 방정식을 동시에 수행해서 데이터를 처리한다.&lt;/p&gt;
&lt;h3&gt;LLM의 구성요소&lt;/h3&gt;
&lt;p&gt;LLM은 여러개의 신경망 층으로 구성되어있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Embedding Layer&lt;/strong&gt;
입력 토큰(입력된 텍스트 등)로부터 임베딩 벡터를 생성한다.
ex) &quot;강아지&quot; -&gt; [0.2, 0.8, 0.1, 0.5, 0.9]
여기서 각각 배열의 값은 토큰의 차원을 나타낸다.
위의 예시를 보면
첫 번째 숫자: 동물과의 관련성
두 번째 숫자: 애완동물과의 관련성
세 번째 숫자: 크기 특성
네 번째 숫자: 친근함 정도
다섯 번째 숫자: 포유류와의 관련성
이런식으로 여러개의 차원으로 해석될 수 있다. 아마 더 많은 차원이 있을 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Feed Forward Layer(FFN)&lt;/strong&gt;
여기서는 임베딩 된 백터를 처리하여 모델이 더 높은 수준의 추상화를 파악할 수 있게 한다.
예를 들어서 &quot;강아지는 귀여운 동물이다.&quot;
임베딩 한 결과를 계산하는 계산하는 층이라고 생각하면 된다.
여기서 긍정적인 감정이 있다는 것과 동물의 개념을 더하는 과정을 통해 복잡한 개념을 이해하도록 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Recurrent Layer&lt;/strong&gt;
해당 층에서는 입력된 텍스트의 단어를 순서대로 해석하며 문장 내 단어들간의 관계를 파악한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Attention Mechanism&lt;/strong&gt;
각 텍스트에서 중요한 부분을 강조하는 층인데
&quot;강아지는&quot;에서 &quot;강아지&quot;에 집중하고 &quot;동물이다&quot;에서 &quot;동물&quot;에 집중하는 것이다.
이런 방식으로 모델이 문장의 의미를 더 정확하게 이해할 수 있게 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. Output Layer&lt;/strong&gt;
이 층에서는 모델이 최종적으로 생성한 토큰을 출력한다.&lt;/p&gt;
&lt;h3&gt;LLM의 유형&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Generic or raw language models(일반 또는 기본 언어 모델)
학습 데이터의 언어를 기반으로 모델을 학습시킨다.
정보 검색 및 문서 요약 등에 사용된다.&lt;/li&gt;
&lt;li&gt;Instruction-tuned language models(명령어 튜닝 언어 모델)
명령어에 대한 응답을 예측하도록 학습시킨다.
감정 분석을 하거나 텍스트 또는 코드를 생성할 수 있다.&lt;/li&gt;
&lt;li&gt;Dialog-tuned language models(대화 튜닝 언어 모델)
대화를 나눌 수 있도록 훈련된다.
심심이 같은 모델이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;LLM이 작동하기까지&lt;/h3&gt;
&lt;p&gt;LLM이 출력 즉, 작동하기 전에 먼저 작업되어야 하는 부분이 존재한다.
Training, Fine-tuning, Prompt-tuning&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Training&lt;/strong&gt;
위키피디아, GitHub등 사이트에서 데이터를 가지고 와서 사전에 훈련된다.
여기서는 지침을 주지 않고 주어진 데이터를 처리한다.
즉, 단어의 의미, 단어의 관계, 문맥에 따른 단어 구분을 학습한다.
right가 correct를 의미하면서 left의 반대를 의미하는지 등을 분석한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Fine-tuning&lt;/strong&gt;
모델을 더 정확하게 학습시키는 과정이다.
번역 상황인지, 법률 문서 작성의 상황인지에 따라서 계약서를 작성해달라고 했을때 차이가 있는 이유는 이 과정에서 학습이 되기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Prompt-tuning&lt;/strong&gt;
이 단계는 Fine-tuning과 비슷하다.
Few-shot prompting과 Zero-shot prompting을 통해 작업이 이루어진다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Prompting이란 컴퓨터와 대화하는 방식으로 임무를 지시하는 코딩이다.&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Zero-shot prompting
이것은 모델이 풀어야 할 문제(Task)를 입력하고 풀어야 할 대상(Prompt)을 입력하면 모델이 학습하는 방식이다.
ex) &quot;Hello&quot;를 번역해줘
여기서 Hello는 Task이고 번역해줘는 것이 Prompt이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;One-shot prompting: 모델에게 한 개의 예시를 보여주고 그 예시를 기반으로 모델이 학습하는 방식이다.
ex) 한국어를 영어로 번역해줘. 안녕 -&gt; Hello 환영해 -&gt;
Hello가 번역된 것이 하나의 예시이고 한국어를 영어로 번역해달라는 부분이 task이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Few-shot prompting: 모델에게 몇 개의 예시를 보여주고 그 예시를 기반으로 모델이 학습하는 방식이다.
위의 예시에서 한가지만 보여줬지만 더 많은 예시를 보여주고 학습시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Chain of thought prompting: 모델에게 생각하는 방법 등 가이드를 제시하는 방법이다.
ex)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; z &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;z&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// z에 10을 선언했으니 console.log(z)는 10을 출력한다.&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드에서 주석에 생각하는 방법을 설명하는 것이 가이드이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zero-shot Chain of thought: 모델에게 생각하는 방법을 알려주지 않고 모델이 생각하는 방법을 추론하도록 한다.
ex)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; z &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y
&lt;span class=&quot;token comment&quot;&gt;// 단계별로 생각해보자&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//출력&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 1. x에 10을 선언한다.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 2. y에 20을 선언한다.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 3. z에 x와 y를 더한 값을 선언한다.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 4. z를 출력한다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문구 하나만으로 모델이 생각하는 방법을 추론하도록 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;+ zero shoot 보다 few shot이 더 정확하며, few shot에서 2개 이상의 예시를 들었을 때의 차이는 크지 않다. zero shot을 쓰는 것보다는 cot을 쓰는 것이 더 정확하다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;추천 LLM&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GPT-NeoX-20B&lt;/li&gt;
&lt;li&gt;GPT-J-6b&lt;/li&gt;
&lt;li&gt;Llama 2&lt;/li&gt;
&lt;li&gt;BLOOM&lt;/li&gt;
&lt;li&gt;Falcon&lt;/li&gt;
&lt;li&gt;CodeGen&lt;/li&gt;
&lt;li&gt;BERT&lt;/li&gt;
&lt;li&gt;T5&lt;/li&gt;
&lt;li&gt;GMixtral 8x7B&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://rimiyeyo.tistory.com/entry/%EB%8B%A4%EC%96%91%ED%95%9C-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81Prompt-Engineering%EC%97%90-%EB%8C%80%ED%95%B4-%EC%82%B4%ED%8E%B4%EB%B3%B4%EC%9E%901-Zero-shot-One-shot-Few-shot-CoT#LLM%20Prompt%20Engineering-1&quot;&gt;라미에오 기록저장소 - 출처1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/what-is/large-language-models&quot;&gt;Elastic What is LLM - 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/blog/open-source-llms-guide&quot;&gt;Elastic LLS 추천 2024 - 출처&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[강아지 ai 봇 만들기 1탄]]></title><description><![CDATA[프로젝트 구상 심심이와 같은 ai…]]></description><link>https://yeaseul7.github.io/neekoblog/dogaiSerise1/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/dogaiSerise1/</guid><pubDate>Sun, 09 Feb 2025 12:40:56 GMT</pubDate><content:encoded>&lt;h2&gt;프로젝트 구상&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;심심이와 같은 ai 봇을 만들어서 대화가 가능하게 한다.&lt;/li&gt;
&lt;li&gt;강아지에 대한 지식을 학습시킨다.&lt;/li&gt;
&lt;li&gt;강아지에 대해 모르는 것을 질문하면 답변할 수 있게 한다.&lt;/li&gt;
&lt;li&gt;강아지 감정을 학습시킨다.&lt;/li&gt;
&lt;li&gt;강아지 감정에 대해 궁금한 점을 질문하면 답변할 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;#x3C;나중에&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Three.js를 사용해서 강아지 모델을 만든다.&lt;/li&gt;
&lt;li&gt;대화 하는 형식으로 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;해당 포스트는 개발하는 과정을 그대로 기록한다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;강아지 ai 봇을 만들기 위해 LLM을 사용해야 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Three.js 블로그에 붙이기 1탄]]></title><description><![CDATA[시작하기 전에 Three.js는 브라우저 환경에서만 동작하는 라이브러리이다.
근데 SSR로 구성된 gatsby에 붙이고자 함은 window객체나 document 객체를 사용하는 것이므로 문제가 될 수 있다. 왜 문제가 될까? SSR은 서버에서 HTML…]]></description><link>https://yeaseul7.github.io/neekoblog/threeJs1/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/threeJs1/</guid><pubDate>Sun, 02 Feb 2025 12:40:56 GMT</pubDate><content:encoded>&lt;h3&gt;시작하기 전에&lt;/h3&gt;
&lt;p&gt;Three.js는 브라우저 환경에서만 동작하는 라이브러리이다.
근데 SSR로 구성된 gatsby에 붙이고자 함은 window객체나 document 객체를 사용하는 것이므로 문제가 될 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;왜 문제가 될까?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSR은 서버에서 HTML을 생성한 후에 브라우저에 전달하기 때문에 document 객체나 window 객체가 없다.
Gatsby의 경우 build시에 이 과정을 수행하기 떄문에 빌드 자체가 깨질 수 있다.
이로 인해 렌더링의 차이가 있을 수 있어서 Hydration 오류를 야기할 가능성도 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해결 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;브라우저 객체를 직접 참조하지 않는다.&lt;/li&gt;
&lt;li&gt;useEffect 훅을 사용하여 브라우저 객체를 참조한다.&lt;/li&gt;
&lt;li&gt;브라우저 객체가 존재하는지 항상 확인한다.&lt;/li&gt;
&lt;li&gt;dynamic import를 사용하여 브라우저 객체를 참조한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;1. Three.js 설치&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# three.js&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;--save&lt;/span&gt; three&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://threejs.org/docs/#manual/en/introduction/Installation&quot;&gt;설치 가이드&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;나는 이미 gatsby에서 빌드하고 있기 때문에 Vite는 별도로 설치하지 않았다.&lt;/p&gt;
&lt;h3&gt;2. sence 만들기&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;THREE&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;three&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; scene &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Scene&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; camera &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PerspectiveCamera&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token number&quot;&gt;75&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerWidth &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerHeight&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token number&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; renderer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;WebGLRenderer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setSize&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerWidth&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerHeight&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;domElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;three.js로 표시하기 위해서는 &lt;strong&gt;장면(scene)&lt;/strong&gt;, &lt;strong&gt;카메라(camera)&lt;/strong&gt;, &lt;strong&gt;렌더러(renderer)&lt;/strong&gt; 가 필요하다.&lt;/p&gt;
&lt;p&gt;카메라는 세가지 종류가 있지만 시작 단계에서는 &apos;PerspectiveCamera&apos;를 사용한다.&lt;/p&gt;
&lt;p&gt;PerspectiveCamera안에 있는 속성의 의미를 살펴보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fov: 시야각 (화면의 범위 / field of view)&lt;/li&gt;
&lt;li&gt;aspect: 종횡비 (화면의 너비 / 높이 =&gt; 이렇게 설정하지 않으면 깨질 수 있음)&lt;/li&gt;
&lt;li&gt;near: 가까운 거리 (카메라가 렌더링을 시작하는 최소 거리)&lt;/li&gt;
&lt;li&gt;far: 먼 거리 (카메라가 렌더링하는 최대 거리)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;near와 far 사이의 공간만 렌더링되며, 이 범위를 벗어난 객체들은 화면에 표시되지 않는다.
지금 단계에서는 크게 신경 쓸 필요는 없지만, 나중에 애플리케이션의 성능 최적화를 위해 이 값들을 조정할 수 있다.&lt;/p&gt;
&lt;p&gt;다음은 렌더러를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; renderer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;WebGLRenderer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setSize&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerWidth&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerHeight&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;domElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;const renderer라고 렌더러 인스턴스를 만들었는데 이외에 앱을 렌더링할 크기를 설정해야한다.&lt;/p&gt;
&lt;p&gt;근데 여기서 위에서 말했던 내 환경 gatsby에 대해 다시 생각해보자.
window 객체에 직접 접근하면 안된다는 말을 떠올리면 해당 코드를 useEffect 훅 안에 넣어야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;ThreeScene&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; containerRef &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; scene &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Scene&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; camera &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PerspectiveCamera&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token number&quot;&gt;75&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerWidth &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerHeight&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token number&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; renderer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;WebGLRenderer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setSize&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerWidth&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerHeight&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    containerRef&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;domElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트가 언마운트될 때 정리&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      containerRef&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token operator&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;domElement&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div ref&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;containerRef&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서 나는 위와 같이 작성했다.
setSize에서 설정한 앱의 크기를 유지하면서 해상도를 조절하기 위해서는 setSize에 false as updateStyle(세 번째 인수)를 넣어야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;renderer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setSize&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerWidth&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerHeight&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 하면 렌더링 해상도만 지정된 크기로 유지되고 안에 있는 요소들은 css를 통해 별도로 지정해줘야 한다.&lt;/p&gt;
&lt;h3&gt;3. cube 만들기&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; geometry &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;BoxGeometry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; material &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;MeshBasicMaterial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token literal-property property&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0x00ff00&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; cube &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;THREE&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Mesh&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;geometry&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; material&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
scene&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cube&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

camera&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;position&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;z &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;큐브를&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CDN이란?]]></title><description><![CDATA[CDN이란? CDN은 Content Delivery Network의 약자이다.
웹 사이트에 접속할 경우 인터넷을 통해 사이트의 데이터가 사용자 컴퓨터로 이동하는데
이 시간을 단축시키기 위해 CDN이 존재한다.
따라서 CDN…]]></description><link>https://yeaseul7.github.io/neekoblog/cdn/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/cdn/</guid><pubDate>Sat, 01 Feb 2025 03:22:22 GMT</pubDate><content:encoded>&lt;h3&gt;CDN이란?&lt;/h3&gt;
&lt;p&gt;CDN은 Content Delivery Network의 약자이다.
웹 사이트에 접속할 경우 인터넷을 통해 사이트의 데이터가 사용자 컴퓨터로 이동하는데
이 시간을 단축시키기 위해 CDN이 존재한다.
따라서 CDN은 웹 페이지 로드 속도를 높이는 콘텐츠 전송 네트워크이다.&lt;/p&gt;
&lt;p&gt;웹사이트를 접속할 때 우리가 눈으로 보는 데이터들은 물리적으로 매우 먼 거리를 이동한다.
이를 위해 CDN이 필요한데, CDN은 클라이언트와 웹사이트 서버 사이에 중간 서버를 둔다.
이렇게 CDN 서버가 클라이언트(사용자 컴퓨터)와 서버(데이터가 존재하는)사이를 관리하며 트래픽을 줄이고, 대역폭 소비를 줄이면서 사용자 환경을 개선한다.&lt;/p&gt;
&lt;h3&gt;CDN이 전송하는 콘텐츠&lt;/h3&gt;
&lt;p&gt;두가지 유형이 존재한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;정적 콘텐츠&lt;/strong&gt;
이 콘텐츠는 사이트에서 주로 바뀌지 않는 부분이다.
mdn으로 예시를 들면 헤더 이미지, 로고, 배너가 된다. 이는 바뀌지 않는 값으로 수정할 필요가 없기 때문에 CDN에 저장하는게 이상적이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동적 콘텐츠&lt;/strong&gt;
날씨, 로그인 상태 같이 자주 바뀔 수 있는 부분이다.
또한 사용자별로 다르게 나타나야 하는 부분일 수 있다. 이것도 CDN을 통해 전송할 수 있는 콘텐츠 중에 하나다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;CDN 동작 원리&lt;/h3&gt;
&lt;p&gt;CDN은 POP(여러 지리적 위치에 접속 지점) 또는 CDN 엣지 서버 그룹을 설정하는 방식으로 작동된다. 지리적으로 분산된 이 네트워크는 캐싱, 동적 가속 및 엣지 로직 계산의 원리를 기반으로 작동한다.
위의 말만 봐서는 감이 잘 안온다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;먼저 CDN이 캐싱으로 작동한다고 했는데 무슨 의미일까?&lt;/strong&gt;
먼저 컴퓨터에서 말하는 캐싱이 무엇인지 이해할 필요가 있다.
컴퓨터에서 말하는 캐싱은 복사본은 저장하는 과정이라고 이해하면 된다.&lt;/p&gt;
&lt;p&gt;한국에서 중국에 서버가 존재하는 사이트에 방문할 때
한국에서 사용자가 이용하는 컴퓨터와 중국에 있는 서버와 통신이 필요하다는 가정을 두자.&lt;/p&gt;
&lt;p&gt;사용자의 컴퓨터를 Client라고 칭하겠다.
중국에 있는 서버를 Origin Server라고 칭하겠다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Client는 중국 서버에 먼저 콘텐츠(정적, 동적)를 요청한다.&lt;/li&gt;
&lt;li&gt;해당 요청은 Origin Server에 도달한다.&lt;/li&gt;
&lt;li&gt;Origin Server는 Client에게 응답을 보내면서 Client와 지리적으로 가까운 CDN POP에 응답하는 내용의 복사본을 보낸다.&lt;/li&gt;
&lt;li&gt;CDN POP은 복사본을 캐싱된 파일로 &lt;strong&gt;저장&lt;/strong&gt;한다.&lt;/li&gt;
&lt;li&gt;이후에 Client가 같은 요청을 보내면 Origin Server까지 가지 않고 CDN POP의 캐싱된 서버에서 응답을 보낸다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위의 경우에는 정적 콘텐츠를 주고 받을 경우 유용할 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CDN이 동적 가속을 이용하는 것은 무슨 의미일까?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이는 CDN과 Origin Server의 연결의 최적화 해서 캐싱을 이용하기 어려운 동적 콘텐츠를 전달할 때 응답 시간을 단축시키는 것이다.&lt;/p&gt;
&lt;p&gt;만약 Client가 직접 Origin Server에 동적 요청을 보내는 경우 네트워크 지연 시간으로 요청이 제대로 가지 않거나 보안 검증 절차에 따라 오래걸릴 수 있다. 하지만 근처 CDN을 이용하면 보안 설정이 이미 되어있거나 지속적인 연결이 원활하게 될 수 있도록 설정되어있을 것이다.
따라서 해당 시간을 단축시킬 수 있다.&lt;/p&gt;
&lt;p&gt;이는 &lt;strong&gt;지능형 라우팅 알고리즘&lt;/strong&gt;을 사용하는데 이에 관해서는 이후에 포스팅 하겠다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;마지막으로 CDN 엣지 로직 계산은 무슨 의미일까?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;클라이언트와 서버 간의 통신을 단순화하는 논리적 계산을 수행하도록 CDN 엣지 서버를 프로그래밍할 수 있다.
예를 들면&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자 요청을 검사하고 캐싱을 수정한다. (요청에 따라서 캐싱의 방식 결정)&lt;/li&gt;
&lt;li&gt;잘못된 사용자 요청을 처리&lt;/li&gt;
&lt;li&gt;응답하기 전에 콘텐츠 최적화&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;CDN의 예시&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Amazon CloudFront&lt;/li&gt;
&lt;li&gt;Azure Front Door&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;내가 아는 예시는 여기까지 이다.
CDN을 사용하면 Ddos 공격으로 부터도 어느정도 보호될 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP 개요 및 기초 이해]]></title><description><![CDATA[HTTP란? HTML 같은 문서를 가져올 수 있게 하는 Protocol이다. Network 카테고리에서 매우 많이 본 Protocol 자세한 내용은 블로그를 참고해 주길 바란다. 프로토콜 HTTP…]]></description><link>https://yeaseul7.github.io/neekoblog/http/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/http/</guid><pubDate>Wed, 08 Jan 2025 03:22:22 GMT</pubDate><content:encoded>&lt;h2&gt;HTTP란?&lt;/h2&gt;
&lt;p&gt;HTML 같은 문서를 가져올 수 있게 하는 Protocol이다.&lt;/p&gt;
&lt;p&gt;Network 카테고리에서 매우 많이 본 Protocol 자세한 내용은 블로그를 참고해 주길 바란다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yeaseul7.github.io/neekoblog/protocol/&quot;&gt;프로토콜&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTP는 클라이언트와 서버가 서로 통신하기 위해 사용하는 프로토콜이다.
중간에 다른 역할을 하는 개체들도 존재한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;게이트웨이(Gateway) : 특정 서버로 가는 트래픽을 관리하는 서버&lt;/li&gt;
&lt;li&gt;프록시(Proxy) : 서버의 데이터를 캐싱해서 클라이언트와 서버간의 트래픽을 최적화하는 서버&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 두가지에 대해서는 아래에서 다시 설명하겠다.
먼저 Client와 Server의 특징에 대해 알아보자.&lt;/p&gt;
&lt;h3&gt;이때 Client와 Server의 특징은 무엇인가?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Client : 요청을 보내는 주체&lt;/li&gt;
&lt;li&gt;Server : 요청을 받아서 응답하는 주체&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Client는 서버에 요청을 보내고, 서버는 요청을 받아서 응답을 보낸다.&lt;/strong&gt;
주로 클라이언트는 브라우저의 역할을 수행함으로 랜더링을 위해 스크립트와 HTML문서를 요청한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Server는 클라이언트의 요청을 받아서 응답을 보낸다.&lt;/strong&gt;
Server는 script를 응답하거나 데이터를 전달하는 역할을 수행한다.&lt;/p&gt;
&lt;p&gt;HTTP/1.1 이후 Header의 기능으로 한개의 IP 주소로 여러개의 포트를 사용할 수 있게 되었다.
이는 &lt;strong&gt;가상 호스트(Virtual Host)&lt;/strong&gt; 라고 부른다.
주로 일처리가 많은 서버는 여러개의 포트를 사용해서 일처리를 하게 된다.
예를 들어서 DB 서버와 웹 서버가 있을 때 웹 서버는 80번 포트를 사용하고 DB 서버는 3306번 포트를 사용한다.&lt;/p&gt;
&lt;h3&gt;가상 호스트에 대해 더 자세히 짚어보자&lt;/h3&gt;
&lt;p&gt;같은 IP에서 다른 도메인을 사용해서 분산처리하는 것을 의미한다.
예를 들어서 &lt;a href=&quot;http://www.naver.com&quot;&gt;www.naver.com&lt;/a&gt; 과 &lt;a href=&quot;http://www.daum.net&quot;&gt;www.daum.net&lt;/a&gt; 이 있을 때 같은 IP 주소를 사용하지만 다른 도메인을 사용해서 분산처리하는 것을 의미한다.&lt;/p&gt;
&lt;p&gt;즉, 서버는 가상 호스트를 통해 여러 도매인으로 클라이언트와 통신할 수 있으며 그때 사용하는 프로토콜은 HTTP이다.&lt;/p&gt;
&lt;p&gt;프로토콜 포스트에서 설명했지만 HTTP는 Stateless 프로토콜이다.&lt;/p&gt;
&lt;h2&gt;Stateful하지 않은 HTTP는 보안을 어떻게 할까?&lt;/h2&gt;
&lt;p&gt;HTTP는 기본적으로 보안 설정이 되어있지 않다.
하지만 TCP와 TLS를 통해 암호화 하여 HTTPS로 보안을 강화할 수 있다.&lt;/p&gt;
&lt;h3&gt;TLS는 무엇인가?&lt;/h3&gt;
&lt;p&gt;TLS(Transport Layer Security)는 데이터를 암호화하여 보호하는 프로토콜이다.
이것을 이용해 암호화된 HTTP 프로토콜을 HTTPS 프로토콜이라고 부른다.
(암호화 관련하여 TLS 이외에 SSL이라는 프로토콜도 존재한다.
SSL은 TLS의 이전 버전이다.)&lt;/p&gt;
&lt;p&gt;HTTP와 HTTPS의 차이는 즉, 보안화된 프로토콜의 차이가 있다고 볼 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;HTTP&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTP는 Header에 의해 확장성이 높다.
HTTP는 header의 다양한 옵션을 통해 추가 기능을 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stateless 프로토콜이지만, Cookie를 통해 상태를 유지할 수 있다.
계속 말했듯이 HTTP는 Stateless 프로토콜이다. 그래서 Cookie를 통해 상태를 유지하곤 하는데, 이 Cookie는 클라이언트에서 데이터를 저장하여 Session을 유지하는 역할을 수행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그인으로 예시를 들어보자&lt;/li&gt;
&lt;li&gt;클라이언트에서 유저가 아이디와 비밀번호를 작성해서 서버에 POST 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;서버는 인증 절차를 거친 후 Session ID를 생성하고 HTTP header의 Set-Cookie 옵션을 통해 클라이언트에 전달한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 받은 Session ID를 쿠키에 저장한다.&lt;/li&gt;
&lt;li&gt;이후 요청시 쿠키에 저장된 Session ID를 함께 전송하여 인증 상태를 유지한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터 손실을 방지하기 위해 TCP를 신뢰한다.
TCP는 데이터를 전송하기 전에 3-way handshake를 통해 연결을 설정하고 데이터를 전송한다.
이는 프로토콜 포스팅에서 설명했다.
&lt;a href=&quot;https://yeaseul7.github.io/neekoblog/protocol/&quot;&gt;프로토콜&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여러 왕복이 필요한 TCP 연결을 설정하기 위해 HTTP/1.0은 기본적으로 요청을 보낼때마다 TCP 연결을 여는 동작을 수행한다.
이는 여러 요청을 보내는 경우 네트워크 부하가 커지는 문제가 있다.
이점을 해결하기 위해 HTTP/1.1은 파이프 라이닝 개념을 도입하고 HTTP/2는 멀티플렉싱 개념을 도입하여 네트워크 부하를 줄였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;HTTP/1.1의 파이프 라이닝 개념&lt;/h2&gt;
&lt;p&gt;개념은 &lt;strong&gt;&apos;작업이 처리가 된 이후에도 TCP 연결을 유지할 수 있게 하는 것&apos;&lt;/strong&gt; 이다.
이걸 &lt;strong&gt;Keep-Alive Connection&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;
&lt;p&gt;이는 응답을 기다리지 않고 단일 연결을 통해 HTTP 요청을 보내고 있는 것을 확인할 수 있다.
이로인해 요청 처리 속도는 빨라질 수 있지만 순서를 맞춰서 응답하는 부분이 다루기 어렵다.
여러가지 오청을 계속 보낼 수 있어서 속도가 빨라진다는 장점이 있지만 HTTP Header는 요청마다 같은 정보를 담기 때문에 비효울적일 수 있다.
같은 정보를 계속 보내면 보내는 데이터 양이 증가한다는 의미이고 이는 회선 비용을 증가시킨다.
헤더는 패킷에 포함되는데 헤더에 데이터가 쌓인다는 것은 패킷의 양도 증가시킨다는 의미이다.
패킷의 양이 많아지면 PPS가 늘어난다.
(PPS란 초당 처리해야 될 패킷 수를 의미한다.)
이로인해 HTTP/2의 멀티 플랙싱 개념이 도입되었다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;HTTP/2의 멀티 플렉싱 개념&lt;/h2&gt;
&lt;p&gt;하나의 연결에서 여러 요청과 응답의 순서를 따로 신경쓰지 않는 방법이다.
HTTP/2의 멀티 플렉싱은 PPS가 늘어나는 한계를 해결하기 위해서 도입되었는데 이는 헤더 압축을 이용한 것이다.&lt;/p&gt;
&lt;p&gt;헤더는 허프만 코드를 이용하여 압축하는데
이 알고리즘은 회전 양이 많아질수록 유리하다.
관련 포스팅은 별도로 남겨두겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[this]]></title><description><![CDATA[실행 컨텍스트를 공부하다가 this에 대한 얘기를 들었다. this는 javascript에서 논란이 많은? 친구이다. 먼저 this…]]></description><link>https://yeaseul7.github.io/neekoblog/this/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/this/</guid><pubDate>Wed, 02 Oct 2024 12:40:56 GMT</pubDate><content:encoded>&lt;p&gt;실행 컨텍스트를 공부하다가 this에 대한 얘기를 들었다.&lt;br&gt;
this는 javascript에서 논란이 많은? 친구이다.&lt;/p&gt;
&lt;p&gt;먼저 this가 무엇이냐?&lt;/p&gt;
&lt;p&gt;함수가 호출될 때 정해지는 함수 컨텍스트이다.&lt;br&gt;
귀에 걸면 귀걸이 코에 걸면 코걸이 같은 것이다.😂&lt;/p&gt;
&lt;p&gt;javascript는 호출될 때
인자, arguments 객체, this를 전달받는다.&lt;br&gt;
이렇게 전달받을 때마다 어떤 걸 바인딩 하는지 결정한다.&lt;/p&gt;
&lt;p&gt;함수 컨텍스트, 실행 컨텍스트에 대해서는 &lt;a href=&quot;https://blog.naver.com/neeko_k&quot;&gt;저번 포스팅&lt;/a&gt;에서 다뤘다.&lt;br&gt;
기본적으로 this는 전역 객체에 바인딩 된다.&lt;br&gt;
이는 혼동을 야기할 수 있다.&lt;/p&gt;
&lt;p&gt;이게 무슨 말이야~
싶겠지만 함수가 어떻게 호출되고 그에 따가 어떤 식으로 달라지는지 살펴보자.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;함수 호출 방식&lt;/h3&gt;
&lt;p&gt;함수 호출 방식은&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;일반 함수 호출&lt;/li&gt;
&lt;li&gt;메서드 호출&lt;/li&gt;
&lt;li&gt;생성자 함수 호출&lt;/li&gt;
&lt;li&gt;call, apply, bind 사용
이렇게 4가지가 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그러면 각각 자세히 어떻게 하는건지 알아보자&lt;/p&gt;
&lt;h4&gt;일반 함수 호출&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//일반 함수&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//외부함수&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// window , &quot;use strict&quot;에서는 undefined나옴&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//내부함수&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// window , &quot;use strict&quot;에서는 undefined나옴&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//화살표 함수&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 외부 함수&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// window (전역 모드) 또는 undefined (&quot;use strict&quot; 모드)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;add2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 내부 화살표 함수&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// add()의 this를 참조&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반 함수 호출에서 this는 다른 함수 안에 있는 내부 함수에서 전역 객체에 바인딩된다.
이런 this의 전역 바인딩을 막기 위해서는 arrow function을 사용하는 방법이 있다.&lt;/p&gt;
&lt;p&gt;arrow function은 es6에 나왔다.&lt;/p&gt;
&lt;p&gt;arrow function의 this는 뭐가 다르다는 걸까?&lt;br&gt;
es6에서 this는 **정의된 스코프(Lexical scope)**를 참조한다.&lt;br&gt;
따라서 상위 환경의 this를 계승 받는다.&lt;/p&gt;
&lt;p&gt;즉 arrow function은 자신이 정의된 위치에서 this를 사용한다.&lt;/p&gt;
&lt;h4&gt;메서드 호출&lt;/h4&gt;
&lt;p&gt;아래의 예시에서 add는 메서드 호출이고 add2는 함수 내부에서 정의된 일반함수이다.&lt;br&gt;
따라서 독립적인 함수 호출이다.&lt;br&gt;
하지만 위에서 설명했던 것처럼 화살표 함수를 사용하면 Lexical scope에 의해 상위 스코프를 참조하여 obj를 가리키게 할 수 있다.&lt;br&gt;
또 다른 변수에 this를 할당해서 사용하는 방법도 있다.&lt;/p&gt;
&lt;p&gt;⚠️메서드를 화살표 함수로 정의하면 그 함수의 상위 스코프를 받기 때문에 전역 객체를 의미할 수 있다.&lt;br&gt;
일반 함수로 작성하고 내부 함수를 화살표 함수로 작성하면 생각하는 대로 계승될 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; methodValue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//메서드&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// obj&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;//내부함수&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// window&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//화살표 함수 쓰는 버전&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; methodValue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//메서드&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// obj&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;add2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;//화살표 함수&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// obj&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//다른 변수에 this를 할당해서 사용하는 방법&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; methodValue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; that &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//메서드&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// obj&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;//내부함수&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s that: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; that&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// obj&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s that.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; that&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100    }&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;생성자 함수 호출&lt;/h4&gt;
&lt;p&gt;javascript에서는 new를 사용해서 생성자 함수를 만들고 호출할 수 있다.&lt;br&gt;
생성자 함수에서 this는 프로퍼티를 상속한다.&lt;/p&gt;
&lt;p&gt;아래에서 생성자 함수를 만드는 방법과 동작 방법을 보여준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 생성자 함수는 대문자로 시작한다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//prototype 객체로 메소드를 가질 수 있다.&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; me &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Lee&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// this에 바인딩 될 객체는 me이다.&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;me&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//Lee&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//new를 붙이지 않을 경우 생성자 함수 아님&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; you &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Park&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;you&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Kim&quot;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//Kim&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//이렇게 this의 속성을 변경할 수 있다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 과정을 그림으로 그리면 아래와 같이 나타난다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/1d54bc915301fea178b3055208d6e605/612f7/this.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 35.2%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAACCUlEQVR42mPoOulR0XTYsbX9hEtT0xGn5vYTri0zL4crMwDBli1LBdcsX163dtWqljUrVjRtWLWqdd2qVdW5ubkgeVE+Pj4hIM0GxOxAzALSw7DkVv7/jTd7/6+41PRv3dXOvxsfNf7vPOCXBJRibW6vdzhz8uT/S+fP/794/vw/IP5/7ODBf7uWLTMB6b125ozRo3v35t+9eXP6jx8/pj169KiN4eDDeX9evHry/+jZPf9u3bv69/6n0/87j/iEgzRMntxndPr0mf/nLlz8/+Dhw38PHz/5f+bUmT8Le3psQPIPb95M+A8EH9+//wOiHz58+J9hwslg5wlHg306dkaE9BwI9Zt0ItR79pVQkFcYbm2byH55ySTrS0un2m+d1u25a3qn17Yprc6rpkzhAclfv33b6vOXLyc/v3t35Mvnz8fu37+/hQEG7EOzeEJDQ5mhXEYwuf8/B8Oa/3YMm/87sM2+68vQfjaYoemUH0P9fh6YvlUMDMw+DAxccD2r/kMMcQ0MFDO2NZasn1/P4ZNWzwWWXPrM2Pjo7/8+hz/8iznz7Z//sc//TfZ++ic177rVfwYGDn8TE1lLPT0x47Q0VpDy+vp6JrgLjY3TWLXsQ3mMfdK4tELreYAamBj6zxt47Xv1O/XAo3/Jx179ST/87L/7npffGebe0wdr4pUSBpL8oAiEGQQAu//879XG8yYAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;thisPrototype&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/1d54bc915301fea178b3055208d6e605/0b533/this.png&quot;
        srcset=&quot;/neekoblog/static/1d54bc915301fea178b3055208d6e605/fac75/this.png 125w,
/neekoblog/static/1d54bc915301fea178b3055208d6e605/63868/this.png 250w,
/neekoblog/static/1d54bc915301fea178b3055208d6e605/0b533/this.png 500w,
/neekoblog/static/1d54bc915301fea178b3055208d6e605/1d69c/this.png 750w,
/neekoblog/static/1d54bc915301fea178b3055208d6e605/612f7/this.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;생성자 함수 동작 방법 찍먹하기&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 생성자 함수는 대문자로 시작한다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생성자 함수 코드 실행 전&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생성할 빈 객체 생성 =&gt; &quot;복사본 만든대~ 빈 종이 가져와&quot;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// this가 빈 객체를 가리킴 =&gt; &quot;내용 여기에 넣으면 돼?&quot;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 빈 객체 : Car의 프로퍼티가 가르키는 객체를 자신의 prototype 객체로 설정 =&gt; &quot;빈종이 : 나 이번 복사에 들어간다&quot;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name &lt;span class=&quot;token comment&quot;&gt;// this를 통해 프로퍼티 및 메소드 추가 =&gt; &quot;복사중 ...&quot;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// this를 통해 생성자 함수가 생성할 인스턴스에 동적으로 프로퍼티를 생성하고 초기화&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생성된 함수 반환&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; myCar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;sm5&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// this가 가리키는 인스턴스를 반환&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;myCar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {type: &quot;sm5&quot;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;생성자 함수 코드 실행 전 생성자 함수가 새로 생성할 객체인 빈 객체를 생성&lt;/li&gt;
&lt;li&gt;그리고 생성자 함수 안에 있는 this가 이 빈 객체를 가리킴&lt;/li&gt;
&lt;li&gt;빈 객체도 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 prototype 객체로 설정&lt;/li&gt;
&lt;li&gt;이후 생성된 빈 객체에 this를 통해 프로퍼티와 메서드 등을 추가한다.&lt;/li&gt;
&lt;li&gt;마지막으로 생성된 객체를 반환한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;이때 어떤 걸 반환하느냐에 따라 this 바인딩이 끊길 수도 있고 반환값이 무시될 수 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;마지막에 생성된 객체를 반환하지 않으면
예상과 다른 값이 출력될 수 있다.&lt;/p&gt;
&lt;p&gt;그 경우를 아래에 예시를 통해 설명한다.&lt;/p&gt;
&lt;h4&gt;생성자 함수가 다른 값을 반환하는 경우&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 다른 객체를 반환하는 경우&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ExceptionConstructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생성자 함수 코드 실행 전&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name
  &lt;span class=&quot;token comment&quot;&gt;// this를 통해 생성자 함수가 생성할 인스턴스에 동적으로 프로퍼티를 생성하고 초기화&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 다른 개체를 반환하면 this가 아닌 해당 객체가 반환&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token literal-property property&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2022&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; myCar2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ExceptionConstructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;sm5&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;myCar2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {year: 2022} 생성자 함수 역할을 못해서 this가 아닌 다른 객체 반환 prototype도 없음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//기본값을 반환하는 경우&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ExceptionConstructor2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생성자 함수 코드 실행 전&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name
  &lt;span class=&quot;token comment&quot;&gt;// this를 통해 생성자 함수가 생성할 인스턴스에 동적으로 프로퍼티를 생성하고 초기화&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 기본타입을 반환하면 this가 반환&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; myCar3 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ExceptionConstructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;sm5&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;myCar2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// {type: &quot;sm5&quot;} 반환 값이 무시되고 this가 반환&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;call, apply, bind 사용&lt;/h4&gt;
&lt;p&gt;이 방법은 명시적으로 this 바인딩 하는 방법이다.
위에서는 this를 명시적으로 바인딩 하지 않았기 때문에 이런 작동 방식을 이해하기 전까지는 왜 저 값이 나오는지 모를 수 있다.
이 함수들은 Function.prototype 객체의 메서드이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function.prototype.apply, Function.prototype.call는 함수를 실행하지만&lt;br&gt;
Function.prototype.bind는 함수에 인자로 전달한 this가 바인딩 된 새로운 함수를 리턴하지 실행하지 않는다는 차이가 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; useThisMethodsValue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; useThisMethodsObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; that &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;

    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; that&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// avoidGloabalObj&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add&apos;s this.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; that&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// avoidGloabalObj&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s this.value: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;add2&apos;s arguments: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1, 2&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;useThisMethodsObj&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;useThisMethodsObj&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;useThisMethodsObj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
useThisMethodsObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;이렇게 함수를 호출하는 방식을 쭉 나열했다.&lt;/p&gt;
&lt;p&gt;그리고 그 안에서 this가 어떻게 바인딩 되는지 코드 예시를 통해 설명했다.&lt;/p&gt;
&lt;p&gt;한 번에 이해하기 복잡할 수 있다.&lt;/p&gt;
&lt;p&gt;이럴 땐 전역 객체를 한다고 하고 아닐 땐 또 다르다고 하고&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;내가 생각하기에 기본적으로 this는 전역 객체를 바인딩 하기 때문에 화살표 함수를 사용해서 상위 스코프를 참조하는 방식으로 예측 가능한 코드를 짜는 것이 좋아 보인다.&lt;/p&gt;
&lt;p&gt;다만 그 과정에서 주의해야 하는 부분도 있기 때문에 그 부분에 대해서도 다시 되짚어보기를 바란다.&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react의 상태(State)에 대해]]></title><link>https://yeaseul7.github.io/neekoblog/reactState/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/reactState/</guid><pubDate>Wed, 02 Oct 2024 12:40:56 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[Next.js의 app-router]]></title><link>https://yeaseul7.github.io/neekoblog/next-app-router/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/next-app-router/</guid><pubDate>Wed, 02 Oct 2024 12:40:56 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[호이스팅]]></title><description><![CDATA[…]]></description><link>https://yeaseul7.github.io/neekoblog/hoisting/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/hoisting/</guid><pubDate>Thu, 26 Sep 2024 12:40:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;들어가면서.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트 코어를 공부하면서 호이스팅과 실행 컨텍스트에 대해서 공부했다.
호이스팅은 너무 유명한 개념에다가 거의 기본 개념 같은 거지만 코어에서 빠지지 않고 나오는 것 같다.
그래서 과거에 정리했던 것보다 더 자세히 정리하고자 추가했다.&lt;/p&gt;
&lt;p&gt;호스팅 하면 실행 컨텍스트에 대한 내용을 빼먹을 수 없는데
호이스팅과 비교하면 매우 머리 아프고 복잡한 과정이다.🥲&lt;/p&gt;
&lt;p&gt;솔직히 한 번만 보고 이해할 수 있다면 당신은 대단한 사람입니다.&lt;/p&gt;
&lt;p&gt;이번 포스팅은 modern javascript 책을 적극 참고해서 작성하였다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;호이스팅이 무엇인가?&lt;/h3&gt;
&lt;p&gt;Hoisting이라는 언어는 끌어올리다는 의미이다.&lt;/p&gt;
&lt;p&gt;js 엔진이 코드를 실행하기 전에 변수나 함수를 메모리에 저장하는데&lt;br&gt;
이게 끌어올려서 저장하는 것처럼 보였나.. 그래서 &lt;strong&gt;호이스팅&lt;/strong&gt;이라고 한다.&lt;/p&gt;
&lt;p&gt;js 엔진이라는 얘기가 나왔다.&lt;br&gt;
그 엔진이 어떻게 하길래 변수나 함수만 쏙 쏙 메모리에 저장한다는 것일까?&lt;/p&gt;
&lt;p&gt;쉽게 말하면 javascript가 코드를 실행하기 전에 먼저 쭉 보면서 평가를 한다.&lt;br&gt;
&lt;strong&gt;&apos;아 여기 x라는 변수 있고... add라는 함수 있고..&apos;&lt;/strong&gt;&lt;br&gt;
이런 식으로 말이다.&lt;/p&gt;
&lt;p&gt;그러면서 &lt;strong&gt;여기 x 있다~ add 있다~ 얘네 저장될 공간 좀 미리 만들어줘~&lt;/strong&gt;
이게 호이스팅이다.&lt;/p&gt;
&lt;p&gt;var로 선언하거나 함수 선언문으로 만들어진 애들은&lt;br&gt;
할당되기 전에 참조할 수 있는 상태가 된다. Reference Error가 나지 않는다.&lt;/p&gt;
&lt;p&gt;이때 변수 선언문이 var로 작성된 애들과 ES6 문법 이후에 let과 const로 선언된 애들은 &lt;strong&gt;다르게 호이스팅된다.&lt;/strong&gt;&lt;br&gt;
둘 다 코드를 평가하면서 메모리를 주는데 그 메모리 환경이 다르다.&lt;/p&gt;
&lt;p&gt;var는 전역 객체로 저장되는 곳으​로 가고
let과 const는 선언만 되는 곳으로 간다.&lt;/p&gt;
&lt;p&gt;그래서 var나 함수 선언문으로 만들어진 애들은 Reference Error가 나지 않는 것이다.&lt;br&gt;
반면 let과 const는 선언만 되었고 초기화는 안되었기 때문에 참조할 수 없는 상태이다.&lt;br&gt;
따라서 Reference Error가 발생한다.&lt;/p&gt;
&lt;p&gt;함수 선언문이라는 말을 자주 사용했다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;함수 선언문과 함수 표현식은 다르다.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 표현식은 변수만 호이스팅되고 함수 자체는 실행되지 않는다.&lt;br&gt;
하지만&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 선언문은 var와 같이 호이스팅되어 함수 자체를 실행 가능하게 한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;호이스팅 하면 실행 컨텍스트가 빠질 수 없다.&lt;/p&gt;
&lt;p&gt;실행 컨텍스트를 이해하면 호이스팅에 대해 더 자세히 알 수 있다.&lt;/p&gt;
&lt;h4&gt;먼저 실행 컨텍스트가 무엇인가?&lt;/h4&gt;
&lt;p&gt;코드를 실행하는데 필요한 환경을 제공하고 실행 결과를 관리하는 영역이다.&lt;br&gt;
실행 흐름을 관리하는 역할이다.&lt;/p&gt;
&lt;p&gt;이렇게만 들으면 감이 잘 안 온다.😅&lt;br&gt;
일단 실행 컨텍스트가 생기는 과정부터 이해해 보자&lt;/p&gt;
&lt;p&gt;ECMA script가 소스를 먼저 구분하고 그에 맞게 실행 컨텍스트가 생긴다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;전역 코드 - 전역 실행 컨텍스트&lt;/li&gt;
&lt;li&gt;함수 코드 - 함수 실행 컨텍스트&lt;/li&gt;
&lt;li&gt;Eval 코드 - Eval 실행 컨텍스트&lt;/li&gt;
&lt;li&gt;module 코드 - module 실행 컨텍스트&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위와 같이 구분하고 각 코드마다 실행 컨텍스트가 생성된다.&lt;/p&gt;
&lt;p&gt;코드들은 평가된 후에 실행 컨텍스트가 생성되고 소스코드가 실행된다.&lt;br&gt;
js는 코드를 실행하기 전에 평가와 실행 컨텍스트 생성 과정을 통해 준비를 한다고 생각하면 된다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1. 전역 코드와 전역 실행 컨텍스트&lt;/strong&gt;
전역 변수 등을 관리하기 위한 최상위의 전역 스코프를 생성하는데 이 스코프를 전역 실행 컨텍스트가 관리한다.&lt;br&gt;
해당 스코프의 전역 변수들은 전역 객체와 연결된다.&lt;/p&gt;
&lt;p&gt;이 과정은 전역 코드가 평가될 때 실행된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 함수 코드와 함수 실행 컨텍스트&lt;/strong&gt;
지역 스코프를 생성하고 그 안의 지역 변수, 매개변수, arguments 객체를 관리한다.&lt;br&gt;
지역 스코프는 전역 스코프에서 시작하는 스코프 체인의 하나로 연결된다.&lt;/p&gt;
&lt;p&gt;마찬가지로 함수 코드가 평가될 때 실행된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Eval 코드와 Eval 실행 컨텍스트&lt;/strong&gt;
strict mode에서 자신만의 독자적인 스코프를 생성하고 관리한다.&lt;/p&gt;
&lt;p&gt;eval()은 js에서 문자열로 된 코드를 실행할 수 있는 함수이다.&lt;br&gt;
일반적인 상황에서 eval은 아래와 같이 쓰인다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;var y = 20; console.log(x);&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 10 출력 -&gt; 현재 스코프의 x에 &apos;접근&apos; 가능하다.&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;number&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 strict 모드에서는&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token string&quot;&gt;&quot;use strict&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;var y = 20; console.log(x);&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 10 출력 x는 현재 스코프에서 참조 가능&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//y는 독립된 스코프에 존재하기 때문에 &apos;undefined&apos;출력&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 독자적인 스코프를 가질 수 있다는 의미이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. module 코드와 module 실행 컨텍스트&lt;/strong&gt;
모듈별로 독자적인 스코프를 생성하고 관리한다.&lt;/p&gt;
&lt;p&gt;module 개념이 ES6 이후에 나온 개념이다.&lt;br&gt;
모듈은 다른 모듈이나 전역 스코프와 독립적으로 동작한다.&lt;br&gt;
import export 키워드를 통해서 다른 모듈의 값에 접근할 수 있는 상황을 생각하면 편하다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이렇게 생성된 실행 컨텍스트들은 선언문으로 생성된 변수나 함수를 해당 컨텍스트가 관리하는 스코프에 등록한다.&lt;br&gt;
그 스코프는 Lexical Environment의 레코드이다.&lt;/p&gt;
&lt;p&gt;Lexical Environment의 끝날 때쯤 설명하겠다.&lt;br&gt;
그냥 이런 게 있구나 하고 넘어가자.🫠&lt;/p&gt;
&lt;p&gt;예시를 보면서 더 자세히 이해해 보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 코드가 있으면 먼저 코드를 싹 돌면서 평가를 한다.&lt;br&gt;
&quot;아.. 여기 x... y.. add 있구나.. 얘네 미리 메모리 공간 줘~&quot; 평가하면서 이 과정도 거친다.&lt;/p&gt;
&lt;p&gt;이걸 &lt;strong&gt;호이스팅&lt;/strong&gt;이라고 했다.&lt;br&gt;
호이스팅 과정에서 전역 객체에 프로퍼티와 메서드가 추가되는 것이다.&lt;br&gt;
이게 &lt;strong&gt;첫 번째 과정인 전역 코드 평가&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;이후에 런타임이 시작된다. 코드를 실행하면서 변수에 값이 할당되거나 함수가 호출되는 것이다.&lt;br&gt;
이때 함수를 만나면 &quot;전역 코드 실행 멈춰~나 add라는 함수 만났어&quot;를 한다.&lt;br&gt;
이건 &lt;strong&gt;두 번째 과정인 전역 코드 실행&lt;/strong&gt; 과정이다.&lt;/p&gt;
&lt;p&gt;전역 코드 실행을 멈추고 함수 코드가 평가되면서 지역 스코프에 변수들이 선언된다.&lt;br&gt;
&quot;add라는 함수 안에 들어왔는데 여기 x 있고.. y 있고.. console.log도 있어~&quot;이런 식으로 말이다.&lt;br&gt;
이때 arguments 객체가 생성되어 지역 스코프에 같이 등록되고 this 바인딩도 결정된다.&lt;br&gt;
세 번째 과정인 &lt;strong&gt;함수 코드 평가&lt;/strong&gt; 과정이다.&lt;/p&gt;
&lt;p&gt;이후에 코드가 실행되는 런타임이 시작된다. 함수 코드가 실행되면서 변수에 값이 할당되고 console을 찾아 log 함수도 실행한다.&lt;br&gt;
&quot;add 안에 x한테 1 y한테 2 줘 그리고 console이라는 애가 어떤 앤지 찾아봐봐, 찾았어? 거기에 Log 있어? 아 함수야? 그거 실행시켜&quot; 이렇게 된다.&lt;br&gt;
이건 네 번째 과정인 &lt;strong&gt;함수 코드 실행 과정&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;네 번째 과정에서 console을 찾는 방법을 간략하게 설명하자면&lt;br&gt;
console이라는 애는 코드상에서 따로 정의되어 있는 게 보이지 않는다. 이건 전역 객체의 프로퍼티로 존재하는데&lt;br&gt;
지역 스코프에서 어떻게 전역 객체의 프로퍼티로 접근하냐면&lt;br&gt;
지역 스코프와 (전역 객체 프로퍼티가 존재하는) 전역 스코프는 스코프 체인으로 연결되어 있다.&lt;br&gt;
그래서 참조를 따라가서 전역 스코프에서 찾아내는 것이다.&lt;/p&gt;
&lt;p&gt;예시를 통해 봤던 위의 과정을 실행 컨텍스트가 관리한다.
그러면 초반에 설명했던&lt;br&gt;
실행 컨텍스트는 &quot;코드를 실행하는데 필요한 환경을 제공하고 실행 결과를 관리하는 영역이다.&lt;br&gt;
실행 흐름을 관리하는 역할이다.&quot;라고 했던 게 조금은 이해가 될 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;조금만 더 깊게 살펴보자🤔&lt;br&gt;
실행 컨텍스트는 위의 과정을 어떻게 실행하나?&lt;br&gt;
실행 컨텍스트는 흐름은 실행 컨텍스트의 stack으로 식별자와 스코프는 Lexical environment로 관리한다.&lt;br&gt;
그러면 위에서 잠깐 보고 넘어갔던 Lexical Environment가 실행 컨텍스트에서 식별자랑 스코프 관리하는 데에 쓰이는 것이라는 것을 알 수 있다.&lt;/p&gt;
&lt;h4&gt;실행 컨텍스트 스택&lt;/h4&gt;
&lt;p&gt;예시 코드를 통해 살펴보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
    y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 코드가 있다.&lt;/p&gt;
&lt;p&gt;이때 스택 전체를 살펴보면
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/021440b8d7ebd854e8b947241390a404/612f7/contextStack.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTElEQVR42lWQPW7CUBCEfSlEKnIgRA4AgQMgBUGUIigICBTIEmAhIox/sFEaQhrMrw3YAoGh4g6Tt6u4oNjizez7dnal2+0G3/dxPB5xOp0QBAHO5zMOhwPrpG23W67Ij3ojn2q/34NYEj1msxlc18Vut8N8PmfT8zz+aBgGYrEYEokENE1jjXwaQL3RMGJQECkMQywWCxapcbVaMVgdDqGqKhRFwUM8jkcBbLfbrOm6zv3L5ZL/REEul8s9MAh8kdTDer1BJp1GMplEpVLBcyaDXC6H93IZT6kUstksD6ataO07IMV0HIeBo9EIzWYTtmUJ0Ade8nl89ft4LRbxViqh1+uhWCigVq3CNE00Gg0YIi1BHbEyhZOu16tItOZjmwL4Wa/jezzGYDCA3GrhdzpFt9uF0ungZzKBLMvQxTks20a9VoPxf1dKTKw/McOJYY8OT78AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;contextstack&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/021440b8d7ebd854e8b947241390a404/0b533/contextStack.png&quot;
        srcset=&quot;/neekoblog/static/021440b8d7ebd854e8b947241390a404/fac75/contextStack.png 125w,
/neekoblog/static/021440b8d7ebd854e8b947241390a404/63868/contextStack.png 250w,
/neekoblog/static/021440b8d7ebd854e8b947241390a404/0b533/contextStack.png 500w,
/neekoblog/static/021440b8d7ebd854e8b947241390a404/1d69c/contextStack.png 750w,
/neekoblog/static/021440b8d7ebd854e8b947241390a404/612f7/contextStack.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;아까 위에서 예시로 계속 설명했던 실행 컨텍스트의 실행 과정과 함께 보면 이해가 &apos;빡&apos; 될 것이다.&lt;br&gt;
이렇게 스택으로 관리하기 때문에&lt;br&gt;
전역 실행 컨텍스트가 일을 멈추고 함수 실행 컨텍스트에서 일을 하고 다시 돌아오는 등의 과정이 있을 수 있는 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Lexical Environment&lt;/h3&gt;
&lt;p&gt;조금 어려울 수 있는 Lexical Environment에 대해서 살펴보자&lt;br&gt;
간단하게 식별자와 그 값 그리고 상위 스코프에 대한 참조를 기록하는 자료구조이다.
조금 더 간단하게는 &lt;strong&gt;스코프와 식별자를 관리하는 저장소&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;예시 코드로 보면 아래의 그림과 같이 해석할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/6213151f003e1d36b0af1c0e6b0eb00f/612f7/environment.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACUElEQVR42j2SbU+SURjH+RptbZrz4eZBBAFFMFEbs9V0veojtFm+ylfNyrH1pi+gnwB1bqZWwyAWDm01ZunU0mlqaSKEoIg8CPfNr8Ot82z/XTvXuc7/XOd3jmZ4yEOPu5e7fQ/p7ukT6sV97wE2ZzfTM+8olYrk8wXC4TCjo6NMTEwwNjZ2La/Xy/j4OCMjIwQCATSeZ4/otEm43U6cHWZsrRIORyM6/Q1mZqeojPPzc0KhkGrg9/tV+Xw+NQaDQVWTk5PMz8+jeeV5jFlrwmrvwGBuoUHfhM5oRdJX4w/MqoaKohCPxygU8iSTx6LjPJnMmXrQWTotcklyuZzIZdA8H+qntkaP2dSG0dSO1mCmVtdMTX0Vcx8uDctlhehRjN29fX5ubPFnP8ra+ibLy2tEIt/58nWJjc1tYvEEmpceYWiwYrK5kESUDM3U6S3USdV8DFxeWZZLlJUCSulExLMKBOKxbfZ2Vkj8+8Xx8R5lOY0iZ9EMD/dTJdkwWl3oGu1IjTbRoZV6bTWfgl6xuYBcTCOnXiMfthJd7eL30m12Ik7+rrg4WO4ktn6H4kELcvJFxfAJks6CxWZFa6zwaxIsLSrDubnZqw4VlHyEci5MNrVA7vQzuVSI/OkCmeQC2ZNFsbYoar6hGRwcwNJqwO4UclyqvcNEg/YmU9Nvrg2RYwKmwkWhIJhWwOZFLKrzymOpOeUUzcDTIcyOHpyu++LvuWm2d2Ft6+ZWg4m3731XhqJaPhIMj0gmtijkDsXmKBfZHVKJHxzHVynmdkVNlP+omwwsi26aswAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;environment&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/6213151f003e1d36b0af1c0e6b0eb00f/0b533/environment.png&quot;
        srcset=&quot;/neekoblog/static/6213151f003e1d36b0af1c0e6b0eb00f/fac75/environment.png 125w,
/neekoblog/static/6213151f003e1d36b0af1c0e6b0eb00f/63868/environment.png 250w,
/neekoblog/static/6213151f003e1d36b0af1c0e6b0eb00f/0b533/environment.png 500w,
/neekoblog/static/6213151f003e1d36b0af1c0e6b0eb00f/1d69c/environment.png 750w,
/neekoblog/static/6213151f003e1d36b0af1c0e6b0eb00f/612f7/environment.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;실행 컨텍스트마다 Lexical Environment가 존재하는데 전역 실행 컨텍스트에 선언되고 할당되는&lt;br&gt;
x와 y 그리고 add 함수는 Global Lexical Environment에 저장된다.&lt;/p&gt;
&lt;p&gt;함수 실행 컨텍스트에 선언되어 있는 x와 y 그리고 change는&lt;br&gt;
Add 함수 Lexical Environment에 저장된다.&lt;br&gt;
그리고 이 둘은 scope chain으로 연결된다.&lt;/p&gt;
&lt;p&gt;코드로 이해했으니 실제 실행 컨텍스트와 Lexical Environment가 어떻게 연결되어 있는지 보자.&lt;/p&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/neekoblog/static/b6d2a17b27f809cc4e55b835a2d3deed/612f7/lexical.png&quot; style=&quot;display: block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA00lEQVR42lWQS6tGUBhG/XgGTA3kdiITkpFvdsQ/IQlJLoXCxnO+d5fBeWvNVuvZbcF1XSiKAl3XoaoqR9M0GIYBWZbheR7onudB0zQoigJt26Ku63/keY6u6yCkaQrf9xGGIYIgwCf+4DdJkHyJ4xhZlmHfd8zzDNM0IUkSH7MsC7b95ceG4zgQRRFRFEFY1xXDMKDve4zjiPM88d593ziOA9u28ShBDr2QBshljIFdjLvXdUGgWFmWqKqKsywLl0h+Q+/ROIXImaaJj9FXUOwN/gFTyBmCJ53SaAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;lexical&quot; title=&quot;&quot; src=&quot;/neekoblog/static/b6d2a17b27f809cc4e55b835a2d3deed/0b533/lexical.png&quot; srcset=&quot;/neekoblog/static/b6d2a17b27f809cc4e55b835a2d3deed/fac75/lexical.png 125w,
/neekoblog/static/b6d2a17b27f809cc4e55b835a2d3deed/63868/lexical.png 250w,
/neekoblog/static/b6d2a17b27f809cc4e55b835a2d3deed/0b533/lexical.png 500w,
/neekoblog/static/b6d2a17b27f809cc4e55b835a2d3deed/1d69c/lexical.png 750w,
/neekoblog/static/b6d2a17b27f809cc4e55b835a2d3deed/612f7/lexical.png 773w&quot; sizes=&quot;(max-width: 500px) 100vw, 500px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;p&gt;먼저 실행 컨텍스트는 Lexical Environment와 variavle Environment 두 가지의 Component로 구성된다.&lt;br&gt;
생성 초기 두 컴포넌트는 같은 Lexical Environment를 참조한다.&lt;br&gt;
Lexical Environment은 식별자를 어디에서 참조할 것인지 등을 알려주는 곳이다.&lt;br&gt;
하지만 variable 환경을 위한 새로운 Lexical Environment 환경이 새로 생기면 다른 곳을 참조하게 된다.&lt;br&gt;
보통 var가 variable Environment Component에 저장된다.&lt;/p&gt;
&lt;p&gt;해당 &lt;strong&gt;스코프의 식별자들을 등록하고 바인딩 된 값을 관리&lt;/strong&gt;하는 Lexical Environment Component는&lt;br&gt;
EnvironmentRecord와 OuterLexicalEnvironmentReference로 구성되어 있다.&lt;/p&gt;
&lt;p&gt;EnvironmentRecord는 해당 스코프에 포함된 식별자를 등록하고 바인딩 된 값을 관리하는 저장소이고&lt;br&gt;
OuterLexicalEnvironmentReference는 상위 스코프를 가리키며 상위 코드의 렉시 컬 환경을 가리키는 저장소라고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;따라서 Lexical Environment는 참조를 통한 Linked List Scope Chain를 구성한다.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;실행 컨텍스트가 Lexical Environment를 통해 식별자를 어떻게 검색하는지 알아보자&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 코드가 있을 때 아래의 과정을 거친다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/e06ccaf52bf1d55babf9465b870acbd7/612f7/flow1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQElEQVR42pVSy4rCQBCc7/biPYIIkpj4Ax78Ak8eAhKCpxyDBBU1DwPBvNBorKUalKzswu5A0T0909XVPaPm8zlmsxm61rIsbLdbcD0eDzyfzz9D2baNxWKB5XKJ9XoN13XhOA6yLBNCXvrPUi/mtm0lkOf5e0//crl8Q1EUaJoGZVkKuH/5VVVBTadTjMdjGIYBXdfF1zRNVLJ1nnfB2Gq1Qr/fF4xGIwwGA/R6PQyHQ6jD4SDz2u12At/34XkeoihCHMfYbDY4n8+4Xq9iGSP2+73cPx6PIAf90+kEVde1yKZctsrE+/0uRczJRBSZpvm2RBiGMh7mcrFdzpx7RQI6t9tN5sZDzipJEqlMJbSvTqiIClmUP+ATisxBECBNUwmQkEPng9Ay8RPMYfEfv033ybsHJKdqktJ2QdLfvs0XgwqS9HO1uGAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;lexical&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/e06ccaf52bf1d55babf9465b870acbd7/0b533/flow1.png&quot;
        srcset=&quot;/neekoblog/static/e06ccaf52bf1d55babf9465b870acbd7/fac75/flow1.png 125w,
/neekoblog/static/e06ccaf52bf1d55babf9465b870acbd7/63868/flow1.png 250w,
/neekoblog/static/e06ccaf52bf1d55babf9465b870acbd7/0b533/flow1.png 500w,
/neekoblog/static/e06ccaf52bf1d55babf9465b870acbd7/1d69c/flow1.png 750w,
/neekoblog/static/e06ccaf52bf1d55babf9465b870acbd7/612f7/flow1.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위에서 열심히 읽어도 이해가 안 가는 게 정상이다..&lt;/p&gt;
&lt;p&gt;차근차근 살펴보자&lt;/p&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/neekoblog/static/04b0b58d888ebda0f5eaa2cdc1a4d920/9bbaf/flow1-1.png&quot; style=&quot;display: block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 117.60000000000002%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAADG0lEQVR42pVUyzPjQRCeP8/iwjFbq6hyWpbEc2OLRDzWNaGKWuXi5pUQlIOTo1dRlAQJkiCqKO9HvL+dr+3wE7tiu+r79UxPd8/Mr78edXx8jEQigZ2dHcTjccQ04n8Qi8VEc/1ZJ17WjY2x1GdnZ1C9vb2w2WwoLi5GZWUlqqurYbfb4XA4UFv7Hd/KylBaWoqqqirRtBN2B33s+FpSIrHMMTExAdXV1YWsrCzk5eWJo6exEa2trXA6naivr4dbz10NDWhpaYGzrg4VFRVo0HOPx6P9fkrC/Px8ZH/KxsjwMNT8/DwCgQDGx8cxOjqKYDCIkZGgaII2f8CPgf5+DA4OCoaGhuD3a9vAgIwZ39fXh3A4DHV+fi7/YHNzE6FQCGtra/Lvtra2RK+vr+Pw8BCUx8dH0ff390ilUkiX29vbp4QMZEIGb29vyw82emNjA0dHR7i7u8PNzY0E7u3tYW5uTsa0MRHBTRR3MztTW/Hw8CCayQgGcc4Ts8LmVGaduZQJzATjRyHVeAOKWTOHUvgPMUH8BZFI5JXNiJqamoLX60VnZyd8Pt8TvD60t7eL3dg4p+7o6EBbWxvqNIU4po3Uo+/i4iJUd/cv5GTnoKioSPjX1NQkHKupqREeulwuHfwDzc3Nwj8Dt9sta/SxfbYhNzdXaKZ6enqE1IWFhUJsEpddUaIJy84haC8vLxdwnZ1UpjuIa9RfCgqE3GNjY1DJZFLoEo1GNTFXhZzhMPloxmHhJ/Xq6ovNCsYyx/7+PhTLnklMJTOJENuQ9T0hv6x8+xeur6+hTk5OpBvYKWw3dsHu7q60I6lBm7X13gMPJwmjkagE861jG4ZWVnTSpIy52cHBwYd4KldO/4ecX1xcvPmHvHambpIT8pPpKibZh65sGj5Twr9VOd0mV07pypimN07pCThPv7L1RXp1ZZJxZmYGy8vL0ot8wRcWFoTES0tLYkt/CHgSNgQZYa2+JCR3+DDSaUVXd3JyEtPT05L09PRUnLhuPTHns7OzQinrRs9FMY8jx5eXl1Llq6urZzs3s77Mxm4eXSt+Aw4/nqcY1SZHAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;lexical&quot; title=&quot;&quot; src=&quot;/neekoblog/static/04b0b58d888ebda0f5eaa2cdc1a4d920/0b533/flow1-1.png&quot; srcset=&quot;/neekoblog/static/04b0b58d888ebda0f5eaa2cdc1a4d920/fac75/flow1-1.png 125w,
/neekoblog/static/04b0b58d888ebda0f5eaa2cdc1a4d920/63868/flow1-1.png 250w,
/neekoblog/static/04b0b58d888ebda0f5eaa2cdc1a4d920/0b533/flow1-1.png 500w,
/neekoblog/static/04b0b58d888ebda0f5eaa2cdc1a4d920/9bbaf/flow1-1.png 588w&quot; sizes=&quot;(max-width: 500px) 100vw, 500px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;p&gt;컨텍스트 스택으로 잠시 올라가서 보자&lt;br&gt;
맨 처음 실행 컨텍스트 스택에서 전역 실행 컨텍스트(Global Execution Context)가 푸시되는 것을 봤었다.
그 과정이다.&lt;br&gt;
그 전역 실행 컨텍스트가 전역 Lexical Environment를 생성한다.&lt;/p&gt;
&lt;p&gt;Lexical Environment 가 어떻게 생겼는지를 다시 보고 와서 참고하기를 추천한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/a2dec304bd5fb1bceb72c0e669b7162a/612f7/flow1-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 39.2%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWUlEQVR42nVRPYvCQBDN/0wj2JpO1GAMnHidjVX+kGBhE4mYiF/4kZwWbgJiRKO+843sYXMDL29nZjPzdsZQSmG73WK32wl/njebjfDlcsF6vUYQBIiiCGEYChPT6RTRC8ydTicYvV4P5XIZjuOgWq2iXq+jVqsJM2aaJobDITzPg2VZ6HS+0Wq10Gw2Ydu2sOu6KJVK8H0fBjtPJhPM53PMZjPpSIzHYwwGA/T7fYkfj0csl0u5S59q8jzH+Xz+49vtBoMforjf31wUoD2fTzweDzlfr1ccDgesVissFgvhOI6RxAmSnxeSRHyOxsiyDPv9XoL8KU1TKcYkfaXSV0yh2+2i0bDRbn/JMzkOzXxypVLBaDSCoVVoYzEN5ggqZ0MuiM/Wy6Iq+lTMmCyFCrlVPoU/ces0zoUXaBwDG9C0AO3r5vosM2RRdsnSTObFhC6olX4q/w+0XxYlN9dBwtHiAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;lexical&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/a2dec304bd5fb1bceb72c0e669b7162a/0b533/flow1-2.png&quot;
        srcset=&quot;/neekoblog/static/a2dec304bd5fb1bceb72c0e669b7162a/fac75/flow1-2.png 125w,
/neekoblog/static/a2dec304bd5fb1bceb72c0e669b7162a/63868/flow1-2.png 250w,
/neekoblog/static/a2dec304bd5fb1bceb72c0e669b7162a/0b533/flow1-2.png 500w,
/neekoblog/static/a2dec304bd5fb1bceb72c0e669b7162a/1d69c/flow1-2.png 750w,
/neekoblog/static/a2dec304bd5fb1bceb72c0e669b7162a/612f7/flow1-2.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위의 Global Lexical Environment는 GlobalEnvironmentRecord와 OuterLexicalEnvironmentReference로 구성되어 있는데 전역이기 때문에 OuterLexicalEnvironmentReference에는 null이 있을 것이다.&lt;/p&gt;
&lt;p&gt;GlobalEnvironmentRecord에는 어떤 것이 있냐면&lt;br&gt;
var 같이 전역 객체에 저장되는 것들이 존재하는 &lt;strong&gt;Object Environment Record&lt;/strong&gt;와
let, const와 같이 호이스팅은 되지만 초기화는 안 되는 것들이 존재하는 &lt;strong&gt;Declarative Environment Record&lt;/strong&gt;(선언적 환경 레코드)로 구성된다.&lt;/p&gt;
&lt;p&gt;호이스팅에서 let과 const는 선언만 된다고 했다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/bb9da4554a53be84edcd7e84ae1bb5ca/612f7/flow1-3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 24.8%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9UlEQVR42n1Oy2qDABD0k4XgBwQ9ePMVz17UU/oX+QJFDyaRFDSgokGJ78Qpu6XQQ+nCMOzO7OwKpmnCtm1YloXD4cBM/el0gqqq0HUdmqbBMAzuSYvjGLvdDpIkQVEU7Pd7iKIIWZYhnM9nXC4XEKdpyuYgCFAUBfI8x/WaomkaDMOAqqp4Xtc17vc7sixDWZYM8hIL4zji+XximiZQ0eKyLBzsOA5834fruvA8j/l4/MA8z9i2jb1UtE9H+77/DiRhGAe8Xi/G+/3G4/FAGIaIoojDfz5PkoQPku8305F1XSFQ8u3zhrZtWey6jpk++K9I/wtf6BlheKXOeJoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;lexical&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/bb9da4554a53be84edcd7e84ae1bb5ca/0b533/flow1-3.png&quot;
        srcset=&quot;/neekoblog/static/bb9da4554a53be84edcd7e84ae1bb5ca/fac75/flow1-3.png 125w,
/neekoblog/static/bb9da4554a53be84edcd7e84ae1bb5ca/63868/flow1-3.png 250w,
/neekoblog/static/bb9da4554a53be84edcd7e84ae1bb5ca/0b533/flow1-3.png 500w,
/neekoblog/static/bb9da4554a53be84edcd7e84ae1bb5ca/1d69c/flow1-3.png 750w,
/neekoblog/static/bb9da4554a53be84edcd7e84ae1bb5ca/612f7/flow1-3.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 전역 객체에 저장된다고 했던 Object Environment Record에 들어가는 애들이 전역 객체에 저장이 된다.&lt;/p&gt;
&lt;p&gt;이런 식으로 실행 컨텍스트가 식별자를 관리한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;여기까지 실행 컨텍스트와 Lexical Environment 그리고 호이스팅에 대해 살펴보았다.&lt;/p&gt;
&lt;p&gt;this 바인딩 그리고 더 자세히 포스팅하고 싶었지만 더 살펴보고 포스팅하고 싶어 그 부분은 미룬다.&lt;/p&gt;
&lt;p&gt;많이 어렵기 때문에 계속 봐야 하는 개념이라고 생각한다.&lt;/p&gt;
&lt;p&gt;틀린 부분 댓글 남겨주면 매우 매우 감사합니다🤗
&lt;a href=&quot;https://blog.naver.com/neeko_k/223597163448&quot;&gt;https://blog.naver.com/neeko_k/223597163448&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로토콜]]></title><description><![CDATA[들어가면서. 웹 개발자로 함은 다양한 네트워크 통신으로 인해 화면이 어떻게 그려지는지 그리고 어떤 방식으로 내가 원하는 데이터가 오고 가는지 이해할 필요가 있다고 생각한다. 그중에서 기초적인 프로토콜과 OSI 7 Layer와 TCP/IP…]]></description><link>https://yeaseul7.github.io/neekoblog/protocol/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/protocol/</guid><pubDate>Fri, 20 Sep 2024 12:40:56 GMT</pubDate><content:encoded>&lt;p&gt;들어가면서.&lt;/p&gt;
&lt;p&gt;웹 개발자로 함은 다양한 네트워크 통신으로 인해 화면이 어떻게 그려지는지&lt;br&gt;
그리고 어떤 방식으로 내가 원하는 데이터가 오고 가는지 이해할 필요가 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;그중에서 기초적인 프로토콜과 OSI 7 Layer와 TCP/IP에 대해 먼저 살펴보고자 한다.&lt;/p&gt;
&lt;p&gt;먼저 프로토콜이 무엇인지 알아보자.&lt;/p&gt;
&lt;h3&gt;프로토콜&lt;/h3&gt;
&lt;p&gt;컴퓨터 내부 혹은 컴퓨터 사이에서 데이터 교환 방식을 정의하는 규칙이다.&lt;/p&gt;
&lt;p&gt;강아지가 기분이 좋으면 꼬리를 흔들고 경계하면 꼬리를 굳힌다.&lt;br&gt;
이는 강아지들 사이에서 통하는 규칙이라고 볼 수 있다.&lt;br&gt;
이처럼 컴퓨터 사이에서도 데이터를 주고 받을 때 규칙이 필요하다.&lt;br&gt;
안그러면 어떤 컴퓨터는 이해하고 다른 컴퓨터는 이해하지 못하는 상황이 생길 수 있다.&lt;/p&gt;
&lt;p&gt;이러한 규칙이 바로 프로토콜이다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/17ff80a605da44089fa14646ef3ee339/612f7/protocolCompute.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJElEQVR42pVRy2rDMBD0/39PaSj0kFMuLSUFQ+ymsR3jtyw7smJJlipPVbXkkFsXht2dYXcWNsBdGLsi6QXSfkbmcj4I1EzdIPQXCFdIqXC1vR9HoKRCnhdo2g6E9EizHFlNwRcLJg2Y0CAXjoELXJXBYqxfFGcVMjdX141HWVbQ2iAYxxFCCDRNgziOYRzZdQSrNTDLAs4nfMQRTp9HTIxBO04piaIo/EWbzSOGYQBjk4dbeEHdEJRVjTQ9o+2oq1tIKb3Rj2EYhjgcDqCUem6eZyTJGROfHR+h7wd3YevMrwikWhBGGba7EE/bPfbhCXScvLu11kNrDWPMb7+uXisqgtf3Ix6e37B7iXBMSq8Hfzouk0Dbc/wnrHtg1TEIqW9P+QZWe8jZQ/7TtAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/17ff80a605da44089fa14646ef3ee339/0b533/protocolCompute.png&quot;
        srcset=&quot;/neekoblog/static/17ff80a605da44089fa14646ef3ee339/fac75/protocolCompute.png 125w,
/neekoblog/static/17ff80a605da44089fa14646ef3ee339/63868/protocolCompute.png 250w,
/neekoblog/static/17ff80a605da44089fa14646ef3ee339/0b533/protocolCompute.png 500w,
/neekoblog/static/17ff80a605da44089fa14646ef3ee339/1d69c/protocolCompute.png 750w,
/neekoblog/static/17ff80a605da44089fa14646ef3ee339/612f7/protocolCompute.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 프로토콜에도 종류가 있다.&lt;br&gt;
상태 프로토콜, 무상태 프로토콜&lt;br&gt;
즉, 기억을 하냐 못하냐의 차이라고 볼 수 있다.&lt;/p&gt;
&lt;h4&gt;상태 프로토콜(Stateful protocol)&lt;/h4&gt;
&lt;p&gt;Server side에서 server와 client가 동작한 상태 정보를 저장하는 형태이다.&lt;br&gt;
이것을 Server의 session에 저장하곤 하는데 이 session 정보에 따라 서버의 응답이 달라진다.&lt;br&gt;
ex)TCP handshake&lt;/p&gt;
&lt;h4&gt;무상태 프로토콜(Stateless prorocol)&lt;/h4&gt;
&lt;p&gt;Server의 응답이 client session 상태와 독립적이며 상태를 저장하지 않는다.&lt;br&gt;
따라서 항상 요청할 때 필요한 정보를 모두 담아서 보내야 하는 상황이 생긴다.&lt;br&gt;
ex) UDP/ HTTP&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/becf2a9d321f7b1a78e9f9f45f4b231b/612f7/client.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 27.999999999999996%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABaUlEQVR42l2RS0sCYRSGJxJyIULUtoT8KUG7fkGLSlxEJdFlE9I+ksiKii5YQlSLbtC2oJtYi8SioDsxXaBRvIwa2jTz9M0UdDnwcl7O4j3n4UieA/BFdTqihpCO78jAcwjbzwago30IaZroGmZFE7v0xFrwn7bTH2+zZPruk2bmboNI0gSUL4AUEpoX3uxiNhTXQSuQzeXJZDKoeRWKMH01TtmyROVqOc41CefGl5eWJBr36kXgjIYjcIk9cI198ALH+IsVPHwmLnovkCu8kUqlUHNZsQDCd5NUiyD3VgW1izZqZm3UbVZQJWZNkYbvwJF77GPP2IMyjqmkdW3wXCAXc6QyWVRVJZ1NQ+lvoGvFhitsw/0n8Ddy6Ac5YCKX8jzIj8iyjPwkW8izNxM/yKsCef0fslc8oEs8wvetrmMDbwR2XsAovfGqJFAUhURSQS8aHCf36Yt5GDjrxB9vt2T63lgrobtRPgFJ/Fij4mP9DwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/becf2a9d321f7b1a78e9f9f45f4b231b/0b533/client.png&quot;
        srcset=&quot;/neekoblog/static/becf2a9d321f7b1a78e9f9f45f4b231b/fac75/client.png 125w,
/neekoblog/static/becf2a9d321f7b1a78e9f9f45f4b231b/63868/client.png 250w,
/neekoblog/static/becf2a9d321f7b1a78e9f9f45f4b231b/0b533/client.png 500w,
/neekoblog/static/becf2a9d321f7b1a78e9f9f45f4b231b/1d69c/client.png 750w,
/neekoblog/static/becf2a9d321f7b1a78e9f9f45f4b231b/612f7/client.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;무상태 프로토콜, 상태 프로토콜은 각각 장단점이 존재한다.&lt;br&gt;
무상태는 서버 사이드에 세션 정보를 저장하지 않는 대신 서버의 자원을 비교적 효율적으로 사용할 수 있다.&lt;br&gt;
하지만 모든 필요 자원을 담아서 보내야 한다는 전제 하에 보안에 취약하다.&lt;br&gt;
상태는 반대라고 볼 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;프로토콜이 컴퓨터가 데이터를 주고 받을 때 쓰이는 규칙이라고 했는데, 그 규칙은 어떤 과정에서 필요한걸까?&lt;br&gt;
바로 데이터를 전송하는 네트워크에서 필요하다.&lt;br&gt;
이 과정에서 많은 프로토콜이 쓰이는데 이것을 계층적으로 구분지은게 모델이다.&lt;/p&gt;
&lt;p&gt;계층적으로 구분지은 이유는 데이터를 한번에 주고 받으면 에러 관리도 힘들고 통신 제어도 힘들다.&lt;br&gt;
이를 계층을 나누고 역할을 분배하여 처리할 수 있게 한다. 이를 분할 정복(Divide and Conquer)이라고 한다.&lt;/p&gt;
&lt;p&gt;대표적으로 OSI 7 Layer 모델과 TCP/IP 모델이 존재한다.&lt;/p&gt;
&lt;h4&gt;OSI7 Layer Model&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/5b6bed2b74a14ed8f5bbe0b13cfb8659/612f7/os7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 81.6%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEFUlEQVR42m2U+1PUZRTGv39D/pBiTWkpIMOqiLKkUqaUpk05NuWEUkpqXBXWQS4rIOiSgjHguguEl0gtAXMFWbUZFxDYbPIGpDCNwuK4C0hi7cqyVz6937WabDozz5wz5zzv857v5RyJv2xycvIZyNbX14fBYKCrq4vu7m6MRiM9PT2Bmt/v5//OSn8n/m1ul5NJn4cnT8YZHhrC4XAwNjbG4OAgdrv9H97jcRfWR/ZnzkqymM/nY2LChdPlAp8b3XUb33Z247I/5r8Xyly3xyNnuWoZZWPjrzjExTLHL3coBz9fu0ZVdTWVVVXUHj9Ko/km+rpGKsoOoikswma1BsRGRkaob2jgqyM11NTUcKW9nau996g9eQpN0V6MTU1IhrNnyc7MJEu1k2yVClVaGpo8NZrdahI+3cTWvFwcbhejQmxvwR4K1LvJyshgp+AVilhbWkpm2nbWxW+kubMD6VTjOeJ2Z7M2P4f3C3NZK/B2dgarsjKIyclgRbmG3xx20aWN5KICPsjJ5L38Xazbk8uanJ3EqlJZk6UiXJ3OkQ4TUkFLM4pDGqJ1JURr97NEe4B5FcWEiNy0IjUrdLWBx7390IayugSl7gBK7RcsFtwo4UMr9hFcVsjUvCJ+uHMP6bOmNsJ03zFbX88sfQOv6hqYfug003T1PJenR116KiDYZrESXnlaoI6Zh+uYLeovawVPYErZCRaqyuntvouUePSSaPkYH+6oIin5MHGJWlYLrNpeSUpsNpfiigOCTb33ic37hnd2HSU+rZJNor4yVc+KHdW8u7UcbWQK1vZupJsbymkNT6NlfhqmRdsxRaTS8so2WmYlc2HqGnrXb376hZtv0KpIpzUyg8vzUwU3HVNokuAmcnFGAu3Bb2I3m5GGk3MYVCzDFrqY4bBohoKjGJ4+l+EXIhiYEoQlNwH5L7S3/cTAotVYFMuxBit5oFiKdcZChl6M5P7zYdxdGMIffdeRPFs3MLFyDs6P5jK2RYl9fTje2CC8y6YzkjqNoc5N+ORRO9+M641QnKtDsW+I4Pf4KNxvvYR/6VTsK4N4cDwcx+iPYvT6PsdtXsCEORpnh4xFeM2hcHUOtwwzOdaYjDwXPLqMxxyFs13JxBXh25R42xXQEcK4aTYnTyr5xXIDqbUzlePfL0F7JoaDdTF8Wfcah+rmoqufR5J+DuXn8wPv8KHNRENTDLWG16moF3wBff0CjpxRsP9EGFsql3PXegeprDWTfONmNBcTKb2YTvGFJPZc2Ezu+Y/5urWE+xYbN67fxtR7jmyRK2hOYJ9xG8XGFPKaPyHHGIfaEE/fwK2ny8Hv8+L3CsheDL6MSRGL/YRz3En/QD/9ln5GH42KxeDG45nA63Hj83rwet0B+AR/kqfr60+eB7cMXoM0iAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/5b6bed2b74a14ed8f5bbe0b13cfb8659/0b533/os7.png&quot;
        srcset=&quot;/neekoblog/static/5b6bed2b74a14ed8f5bbe0b13cfb8659/fac75/os7.png 125w,
/neekoblog/static/5b6bed2b74a14ed8f5bbe0b13cfb8659/63868/os7.png 250w,
/neekoblog/static/5b6bed2b74a14ed8f5bbe0b13cfb8659/0b533/os7.png 500w,
/neekoblog/static/5b6bed2b74a14ed8f5bbe0b13cfb8659/1d69c/os7.png 750w,
/neekoblog/static/5b6bed2b74a14ed8f5bbe0b13cfb8659/612f7/os7.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 모델은 산업 표준 모델이다.&lt;br&gt;
초창기 네트워크의 표준을 만들기 위해 해당 모델이 나타났다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI 7 Layer - Application Layer[응용 계층]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/f7fba7bc510ae158fd8f106d5257dcb3/612f7/applicationLayer.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA50lEQVR42p1RQWrDMBDUY3vvKW/psVByyKnQLyQphFxydHwytXGM7chgWYpsydJUkknrgKHQgUG7y7IzuyJwsAv0kFKiaRq0bRs4DAPu8D3GTrT2pwzik1n+AMYYkiRBURTI8xycc/wFMlecDx7H0SlPFa11oFIKxpjQyXuDXSzweRZohZlmuHZySgY8v9ZYvXle8fRSYh8Jt4sE6zgopciyLDhN0xRVVUM4p7LX+LreEJUSvf61QuKLwnrL8HHkeD902Ow7XBrt5EZ3MwUhRFjVv/fY39K7p3WFoqLLK/8H4ST28Qe+ARutz5B7rnDTAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/f7fba7bc510ae158fd8f106d5257dcb3/0b533/applicationLayer.png&quot;
        srcset=&quot;/neekoblog/static/f7fba7bc510ae158fd8f106d5257dcb3/fac75/applicationLayer.png 125w,
/neekoblog/static/f7fba7bc510ae158fd8f106d5257dcb3/63868/applicationLayer.png 250w,
/neekoblog/static/f7fba7bc510ae158fd8f106d5257dcb3/0b533/applicationLayer.png 500w,
/neekoblog/static/f7fba7bc510ae158fd8f106d5257dcb3/1d69c/applicationLayer.png 750w,
/neekoblog/static/f7fba7bc510ae158fd8f106d5257dcb3/612f7/applicationLayer.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;소프트웨어가 사용자에게 데이터를 제공하기 위해 의존하는 프로토콜이다.&lt;br&gt;
이 Layer는 이메일이나 브라우저 같은 소프트웨어 애플리케이션이 통신을 열기 위해 존재한다.&lt;/p&gt;
&lt;p&gt;대표적으로 &lt;strong&gt;HTTP, FTP, Telnet, DHCP&lt;/strong&gt; 프로토콜이 존재한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI 7 Layer - Presentation Layer[표현 계층]&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/61ae04e3bcb0b7e2318e2f7e3dcd608f/612f7/presentationLayer.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyUlEQVR42n1RVw7CMAzt/U+FECfgA75DKFUF3VltxiODihaqWopiWX7DdoaNcM7Fv2kaEEJwozS+PM9jbQ7rQu8am2EnxnHEMDCwoQdnPdq2hZRyD7ImNF6y5cYrO69sYa1NTpkFeerkyte0NjE/XTnoa/pMtSCcXQ/SoewSidYaSo2BArQyOJMEnKbJu1QRdbwqHC7yn3COuq78nu4QQnxdG4OiKED9Djnnq3pXlygeecw3Rw47C6BlQziQUiqK/NaFUHGnbnGZNxqh1fzdhSuSAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/61ae04e3bcb0b7e2318e2f7e3dcd608f/0b533/presentationLayer.png&quot;
        srcset=&quot;/neekoblog/static/61ae04e3bcb0b7e2318e2f7e3dcd608f/fac75/presentationLayer.png 125w,
/neekoblog/static/61ae04e3bcb0b7e2318e2f7e3dcd608f/63868/presentationLayer.png 250w,
/neekoblog/static/61ae04e3bcb0b7e2318e2f7e3dcd608f/0b533/presentationLayer.png 500w,
/neekoblog/static/61ae04e3bcb0b7e2318e2f7e3dcd608f/1d69c/presentationLayer.png 750w,
/neekoblog/static/61ae04e3bcb0b7e2318e2f7e3dcd608f/612f7/presentationLayer.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;데이터를 사용할 수 있게 해주는 계층이다.&lt;br&gt;
데이터를 사용할 수 있게 암호화, 변환, 압축을 담당한다.&lt;br&gt;
이렇게 데이터를 변환하는 이유는 수신하는 노드(컴퓨터)가 다른 인코딩 방법을 사용할 수 있기 때문이다.&lt;/p&gt;
&lt;p&gt;대표적으로 &lt;strong&gt;ASCII, MPEG, JPEG 프로토콜&lt;/strong&gt;이 존재한다.&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI 7 Layer - Session Layer[세션 계층]&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/613a54246049dc0d43e4b36ab07efb11/612f7/sessionLayer.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVR42pWRbQ7CIAyGd2dP4TG8gX/1FHoEkwE6MyIIY4zCKyMz0R8S1+Rt0rR90o8GFfNTQNuyrBac8yIiqrWg+ZVIix8GC611kVIKKaV1wHd5oITjyeByDyWOGTSz5JMQ4xrgQpwbN7sbDmcz40BhwvVB2O57CBm+av9a2fm87hjgnIP3vshYB2XGdRN+mrUWjDF0XQchBFh+jpR99YYv+f/Wa4PCLIIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/613a54246049dc0d43e4b36ab07efb11/0b533/sessionLayer.png&quot;
        srcset=&quot;/neekoblog/static/613a54246049dc0d43e4b36ab07efb11/fac75/sessionLayer.png 125w,
/neekoblog/static/613a54246049dc0d43e4b36ab07efb11/63868/sessionLayer.png 250w,
/neekoblog/static/613a54246049dc0d43e4b36ab07efb11/0b533/sessionLayer.png 500w,
/neekoblog/static/613a54246049dc0d43e4b36ab07efb11/1d69c/sessionLayer.png 750w,
/neekoblog/static/613a54246049dc0d43e4b36ab07efb11/612f7/sessionLayer.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;세션이란? 여기서 session은 통신이 시작될 때부터 종료 시점까지를 의미한다.&lt;br&gt;
따라서 이 계층은 통신 시작과 끝을 결정하는 역할을 하고 리소스를 낭비하지 않게 세션을 개방하고 닫는 등의 역할을 한다.&lt;br&gt;
데이터를 전송하다가 중간에 끊기면 처음부터 다시 전송을 재개해야하는데&lt;br&gt;
이 계층에서 체크포인트를 설정해서 그 지점부터 재전송을 할 수 있게 한다.&lt;/p&gt;
&lt;p&gt;대표적으로 &lt;strong&gt;SSH, TLS, RPC 프로토콜&lt;/strong&gt;이 존재한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI 7 Layer - Transport Layer[전송 계층]&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/d11b1468a04c48cdf9bb42cb02d5b2d0/612f7/transport.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAs0lEQVR42pWPiwqDIBiFe//X2JvsLUYUrZojDWoVXv7UMxNqFxYxQYXj+c5/THCwhBAoyxKM3cE5P7IjOTIopdB1PcbhgWma/g30GJUFzW5TnAcoHJI8vH853aJpGzS/H7jAeWMxyAA7C601tLEohMXpPCJlJswkEIVtgT74yP4IXKe0bYs0K1DXtwitbxXjuGRVaEQb2DQcWX6NzG5DYwyUlKGZ+vjKTAbmS4teJeP9HvgE+4/XBR59P+AAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/d11b1468a04c48cdf9bb42cb02d5b2d0/0b533/transport.png&quot;
        srcset=&quot;/neekoblog/static/d11b1468a04c48cdf9bb42cb02d5b2d0/fac75/transport.png 125w,
/neekoblog/static/d11b1468a04c48cdf9bb42cb02d5b2d0/63868/transport.png 250w,
/neekoblog/static/d11b1468a04c48cdf9bb42cb02d5b2d0/0b533/transport.png 500w,
/neekoblog/static/d11b1468a04c48cdf9bb42cb02d5b2d0/1d69c/transport.png 750w,
/neekoblog/static/d11b1468a04c48cdf9bb42cb02d5b2d0/612f7/transport.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;세션 계층에서 데이터를 가져와서 세그먼트 단위로 조각내는 역할을 한다.&lt;br&gt;
연결 속도가 빠른 쪽이 느린쪽을 압도하지 않도록 전송 속도를 조정하기도 한다.&lt;br&gt;
또한 수신 완료 여부를 파악하고 오류 제어를 수행한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI 7 Layer - Network Layer[네트워크 계층]&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/10b04d41439319903f4d548258211ff5/612f7/network.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAy0lEQVR42o1Qy24CMRDj/7+kX9I7Vw5oUV7qSlSbJWGyZCZukgWEaEG1FCnyeGwnGzyhXE9DzhlKKwzDAGMsrLWde4fNu2EpBSEEzLNHDCd47yEi/zdkLhinDFoEpS4yczUFYio4nqTfV04QSOAjP7znD8NLne9cxkwFwhnLkqqZYHu44OMz1CBGSql6CL4mgfmW1w1bstYayjgopRFjXEMyYz9oWOfuS+M4dq0xBq7y7Wt+GTaSiHoDonMPuPFL5VrbG1YN3fWPDX8AuT/VsRIYh6QAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/10b04d41439319903f4d548258211ff5/0b533/network.png&quot;
        srcset=&quot;/neekoblog/static/10b04d41439319903f4d548258211ff5/fac75/network.png 125w,
/neekoblog/static/10b04d41439319903f4d548258211ff5/63868/network.png 250w,
/neekoblog/static/10b04d41439319903f4d548258211ff5/0b533/network.png 500w,
/neekoblog/static/10b04d41439319903f4d548258211ff5/1d69c/network.png 750w,
/neekoblog/static/10b04d41439319903f4d548258211ff5/612f7/network.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;전송 계층의 세그먼트를 송신자의 장치에서 패킷 단위로 쪼갠다. 그리고 수신 장치에서 다시 패킷을 조립한다.&lt;br&gt;
이런 과정을 진행할 수 있게 데이터가 최적의 경로로 이동할 수 있게 라우팅한다.&lt;/p&gt;
&lt;p&gt;이 계층은 송신 장치와 수신 장치가 같은 네트워크에 있다면 필요 없다.&lt;/p&gt;
&lt;p&gt;대표적으로 &lt;strong&gt;IP, ICMP 프로토콜&lt;/strong&gt;이 존재한다.&lt;/p&gt;
&lt;p&gt;장비 : 라우터&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI 7 Layer - Data Link Layer[데이터 링크 계층]&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/76dc952cf2c5294b67d467af2fa7d92a/612f7/dataLink.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7ElEQVR42n1Ry27CMBDMx/Fn/AdnDv0HbiBOiGMroYYodpRIVRsX128Pa1tAUiRWWtm7Ho93xhUmEWPJEEttjEHTNGjbFpx3lBxa6xk2Rsyiwr+YAkIIEEJAjCPkRWCk1XuPV1FNSb5+HfYfEnVvqBngnM9n0kQ6CxmTevQURulx/NTov11iIFx8EN4kHgiwWDKsNiJfSvKkDjieLdbbC/6MJxt0Juh/At52Cu/czZRVD6kRwzDgVDOcmxbW2vtEp5o87LpcJ8mcMbCU5Gnxl2drngjTJ1iaQGuV/bv3qS6TlVoplTPhbnvnyqRXKtHRdiYsEZ8AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/76dc952cf2c5294b67d467af2fa7d92a/0b533/dataLink.png&quot;
        srcset=&quot;/neekoblog/static/76dc952cf2c5294b67d467af2fa7d92a/fac75/dataLink.png 125w,
/neekoblog/static/76dc952cf2c5294b67d467af2fa7d92a/63868/dataLink.png 250w,
/neekoblog/static/76dc952cf2c5294b67d467af2fa7d92a/0b533/dataLink.png 500w,
/neekoblog/static/76dc952cf2c5294b67d467af2fa7d92a/1d69c/dataLink.png 750w,
/neekoblog/static/76dc952cf2c5294b67d467af2fa7d92a/612f7/dataLink.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;네트워크 계층에서 받은 패킷을 더 작은 프레임으로 세분화한다.&lt;br&gt;
이 프레임들이 통신하는데에 있어서 흐름과 오류를 제어한다.&lt;br&gt;
이 계층은 같은 네트워크에 있는 장치들 간의 데이터 전송도 담당한다.&lt;/p&gt;
&lt;p&gt;데이터 링크 계층은 머리와 꼬리에 데이터 수신 장치와 송신 장치 주소 등의 정보를 제공한다.&lt;br&gt;
그 정보는 MAC주소라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;MAC : Media Access Control Address&lt;/p&gt;
&lt;p&gt;대표적으로 &lt;strong&gt;이더넷(Ethernet), PPP, UART 프로토콜&lt;/strong&gt;이 존재한다.&lt;/p&gt;
&lt;p&gt;장비 : 스위치, 브릿지&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI 7 Layer - Physical Layer[물리 계층]&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/f599711a95a7c1251b95b3f1cb34aa38/612f7/pys.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsElEQVR42o1QCwrDIBTr/U9ZVi1txzb8TDd/mREcLYyyQEDiM8lzwAlijBBCYBxHSCkxz3PTzjCcXZZS4JyDMaZRa42c8/+GD5twN7E96kwpwVrbDNmOIV2/qgjtEqN/G2qfcTMZIcTK0AzYkKtyZRpT412I1VBnPN/l2JCJBBuIaaq8QCn1HWCTZVmwbVs7d6zrillONUgc5of9Q+99a7T/eAZSJ3s4EcK7zlJ/HeY/DbXWTmUbWJQAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/f599711a95a7c1251b95b3f1cb34aa38/0b533/pys.png&quot;
        srcset=&quot;/neekoblog/static/f599711a95a7c1251b95b3f1cb34aa38/fac75/pys.png 125w,
/neekoblog/static/f599711a95a7c1251b95b3f1cb34aa38/63868/pys.png 250w,
/neekoblog/static/f599711a95a7c1251b95b3f1cb34aa38/0b533/pys.png 500w,
/neekoblog/static/f599711a95a7c1251b95b3f1cb34aa38/1d69c/pys.png 750w,
/neekoblog/static/f599711a95a7c1251b95b3f1cb34aa38/612f7/pys.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Hub, router, cable 등 물리 매체를 통해 상위 계층에 전송된 데이터를 다른 시스템에 전기적 신호를 통해 전송하는 계층이다.&lt;br&gt;
대표적으로 &lt;strong&gt;1000BASE-T, RS-232, RS-485 프로토콜&lt;/strong&gt;이 존재한다.&lt;/p&gt;
&lt;p&gt;장비 : HUB, 리피터, 모뎀&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;TCP/IP 4 계층&lt;/h4&gt;
&lt;p&gt;TCP는 OSI 7과 다르게 각 계층이 종속적으로 이루어져있다.&lt;br&gt;
OSI가 있는데 TCP가 또 만들어진 이유는 IP 규칙으로만 통신하기에 불안정 했던 단점들을 커버하기 위함이다.&lt;/p&gt;
&lt;p&gt;이는 패킷 전송을 제어해서 신뢰성을 보증한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/b9653496f9c72eddffbc75e7099804d7/612f7/os7Layer.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 82.4%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAADoElEQVR42mWU208bVxCH93/sW/vQpz61fchDqyZV27Rqqqh5qBRFSaQEyqUhlBIIlHBxwsU4hWBsjAFfF3t9t9dee7279vqy2F/PWoBQO6vR7B6t5nxn5ndG8sZqTHtCvNw6ZWLVz1q4TLPdYzgc4lwMuBhcuvi+eh+Kx7J7nOYNIkWLSMHkVLhcsZAOzuusB7O8Pc7jCeXxxWtYnT6uuUlvumtuQtfcTVdPamzETDwxg9VIE1+ygeRLaMztRln4J8HLzTAbJ2Xa/QFVtUwgGEA+TxJPxESUKZVKpJQ09XoNs3vB0lGJ8bUjfl8PMe45xXfeRNqXNVYO0yPKNyJuR1XaPQejqZPJZigUChSKeXq9nsvMJeiIcDlU5sV2lFlvnBmvjE/W3YQ6y36FFX+aeUG6Fbl5ZP5nV2uG3Wcr1mAnaQo32Iwb+NMG0k68xNKBLOgUFt9HRVOyNKw2g+GAvuNcN2JwWcduv48j1jWzJWpWIpgzCeVbHGR0AkoF6XVoir3YDtlKnmAiwOLxJKpZGlG4SZqGgWGao9jQdapajXRK4SwdZjE0QSgZIKkk2Q5vsBadQ5re/5WZ3Ye8Cy+L5jzj+e5dys389RGbRpOmKZI1Gmj1+mgT1/INhbH3d3n9YZL1wCumvb/xKvQIqR6/TTI8wWHQS+xsBS36FR0rRVvUUTd0dEHV6XawLGsUUymZ00gSJblD/ugWuYwXtSaTic2gRn5AcmKfYSfucLD+gGr4PsQ/xmmlaFo2pXIRJZtFrVap1TU0TaNSLqHposbtOPqHj8j671GNPye18yVm+HOk4t8/kdgeJ3Gyy5lvnuLS99i1DK58nQuHVruFLcjc2BHScSkLlSoVJYJ1OMawGmCoxxjk3mEezSJp8z+jrT1m/69nKG/GaP75HZ1ablSnXq/LuTiiS3guyyiKMlpzN7O1IsbWOEnPLJG3C+Q8f9A+WECqLT9A3V9ATZ1RCW1RX7pPS83QEffY7Wyn2xWEXVFTm56QTKtl0Rd96dULlF7cZu/ptxxN/cLew1u0Np+IhPM/cjx1j8LeEifzj1BnvqFfz4skPUGVJJU+FzelgCy7pCrZjELXGdKrZqg9/oTG5BcYs19Tf/opjbk7SK1chH4pMfqhr6aws2E6toVzKeYrH15OG1fwjitw26Ql+2mng7Qzx9ipQ+zcmahhQyedLxAXBNlCkVhSvp4s/502N6fOSKOmhVIoUayoRBKyuAAW/wJJBX+gFNXhfQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/b9653496f9c72eddffbc75e7099804d7/0b533/os7Layer.png&quot;
        srcset=&quot;/neekoblog/static/b9653496f9c72eddffbc75e7099804d7/fac75/os7Layer.png 125w,
/neekoblog/static/b9653496f9c72eddffbc75e7099804d7/63868/os7Layer.png 250w,
/neekoblog/static/b9653496f9c72eddffbc75e7099804d7/0b533/os7Layer.png 500w,
/neekoblog/static/b9653496f9c72eddffbc75e7099804d7/1d69c/os7Layer.png 750w,
/neekoblog/static/b9653496f9c72eddffbc75e7099804d7/612f7/os7Layer.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP-Network Interface Layer[네트워크 인터페이스 계층]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;하드웨어적인 요소와 관련된 모든 것을 지원하는 계층이다.&lt;br&gt;
물리적인 주소를 지정하고 오류를 감지해낸다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP - 인터넷 계층&lt;/strong&gt;
패킷을 목적지까지 전송하는 역할을 하며 라우팅, 주소 지정, 패킷 포워딩 등을 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP- 전송 계층&lt;/strong&gt;
애플리케이션 간에 데이터 흐름과 오류를 제어한다.&lt;/p&gt;
&lt;p&gt;이 과정에서 일어나는 TCP 3-Way Handshake와 4-Way Handshake를 알 필요가 있다.&lt;/p&gt;
&lt;p&gt;먼저 데이터를 전송하기 전에 연결하는 과정에서 3 Way Handshake가 일어난다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/87c30dbfc3cb8e423edf289826832fd7/612f7/tcp.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 86.4%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC5klEQVR42nVUiW7aQBD1/39Lq1ZVo0Rp1BwNCRAF5QLZwYYUSDE2vm977deZBVPStCOt7PWO37yZebNKnueoqgqWZUFVVWi0HMeR3/isrmu01jQNiqKQi8+n0yl835c+7FuWJRTXdVHSoRcE8MMQOTmnWSYdoihCmqY7wCRJ5D6jc7nINyAfl0AbOjcmEyghbSAEVrMZ3OUSFBrNlhUz2QfkAMxSsmUfYuSvVvhFTNnGmgbFMwwEP85hHB5A+/IZcfcKFbGVgMRyHzCO410wEYUIOpdYnBzj6dNHpL0utO41lGBtQ9ByJgQ8+4nKtlBTZLbyL4YScMuQfUp7BXeiwzHGQODheTiEwmm06SR5gZhWFCeyRvzN8zws/QqmL96mLBIgfcRycorJ6IjSGUJXbwiQkCFSOOYMWeQQrZgLJDvHAK7rof9SomsUWFKNmWVGQdPYQ+o8Ud3vYc0HQD6Frt1BiS0dgfoN+tVHjDsfkBrnFM1/k3JNpCpRSzBBDWQF8GJbriys12v5rus6MfQsNImJcGUg8+aoY5PSKTaA5T9qWG9SLtISTz0V/bMBeqe3GN5oGPTv3taQo7cCZqsIcGGFePUE5m6FmenLLotaIPQj3PdGGHQeMLp9xnQ0x/3t4x9AjwRumktilEjwmETM9e1rDjp6jbNngb5qIU2oecS6TTnNNkJnM0iC7xgyu5YhCzuKYviJgB9XCEif+6PIlu9pdVPDPcAwpOgkGa4VjxlLxrZsXOklrqjLpmkiZvbb87IosTJXMtAOMAw3m7VjkxxSmsl6x5CHndNLigZxJiTbNgOe/0oQoG3CcTddHutjKC/mFN8HJzjofMVx/wgXD6ck7uhdOm2XuSGydlWKi8czHF4f4Kh7iMvhBXp3XShr38bSe8ViPcers5DvHFnWsPz/6FV1tftvYc+xji0MtSFfXzQp5FOTcGvRyGeRF9uGRLJWrYV0vWXbq4195D+kS0Hps6mqht+zvA/KSnjYRgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/87c30dbfc3cb8e423edf289826832fd7/0b533/tcp.png&quot;
        srcset=&quot;/neekoblog/static/87c30dbfc3cb8e423edf289826832fd7/fac75/tcp.png 125w,
/neekoblog/static/87c30dbfc3cb8e423edf289826832fd7/63868/tcp.png 250w,
/neekoblog/static/87c30dbfc3cb8e423edf289826832fd7/0b533/tcp.png 500w,
/neekoblog/static/87c30dbfc3cb8e423edf289826832fd7/1d69c/tcp.png 750w,
/neekoblog/static/87c30dbfc3cb8e423edf289826832fd7/612f7/tcp.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 SYN는 synchronize sequence numbers ACK는 acknowledgements의 약자이다.&lt;/p&gt;
&lt;p&gt;그림대로 3번의 확인 절차를 통해 연결할 준비를 한다.
클라이언트와 서버가 &quot;너 데이터 받을 준비 됐어?&quot; -&gt; &quot;나 준비 완료&quot; -&gt; &quot;나도 준비 완료&quot; 이런 과정을 거친다고 생각하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CLOSED는 닫힌 상태
LISTEN은 요청 대기 상태
SYN-SENT는 SYN 요청 상태
SYN-RECEIVED는 SYN 요청을 받은 상태
ESTABLISHED는 연결 확인 상태 이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그리고 데이터 교환 과정이 일어난다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/b175c88cd07a2da17ef3cc86ca6952b5/612f7/3hand.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 21.6%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwUlEQVR42m2PzZKDMAyD+/7Pt0eGLh1ogQLOD4SQEL4FyqUz65Msy7J167qOqiq53wvEOhpj0X6mfO5cnhGjZ/EOOwtV/aJpWoriF62E/+q2bdsJjNG4ENFhw66Qv4WfsqH1CVkSlUv0ouDSL5NmGlrGoWGSN1tKH8N0AaUUa4wc8rBTo/fU/YDam9cUyMxCJ3IuHp6zFXT9QJ45Q5kRZvf9oTWG3gV6vzLGtMeOKOdZ93n6SM6jh/wwXYP/znr5/AHOTzXT9eGFOgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/b175c88cd07a2da17ef3cc86ca6952b5/0b533/3hand.png&quot;
        srcset=&quot;/neekoblog/static/b175c88cd07a2da17ef3cc86ca6952b5/fac75/3hand.png 125w,
/neekoblog/static/b175c88cd07a2da17ef3cc86ca6952b5/63868/3hand.png 250w,
/neekoblog/static/b175c88cd07a2da17ef3cc86ca6952b5/0b533/3hand.png 500w,
/neekoblog/static/b175c88cd07a2da17ef3cc86ca6952b5/1d69c/3hand.png 750w,
/neekoblog/static/b175c88cd07a2da17ef3cc86ca6952b5/612f7/3hand.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ESTABLISHED 상태에서 데이터를 보내면 송신, 수신측은 전송이 잘 되었다는 의미로 ACK 응답을 보내는데&lt;br&gt;
이게 안오거나 하면 송신측이 계속 데이터를 보낸다.&lt;/p&gt;
&lt;p&gt;데이터를 교환하고 연결 종료 될 때 4 Way Handshake 과정이 일어난다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/6e3acdce9b6b407da6e5a9e623787042/612f7/4hand.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVR42m1SXXOEIBDz///Atg+np4eoKIgfKBaEdOWuD+0cMxlQstmYNQshgDGGvKjgN4tzWRDNhk1rTEoB54lInGtN04QYYzrjd/+3soUEinuBW15SLZFiSORvY7AOAwLdexL3vEHPWyg6C9FhmcaX8NUsPhsQssuh9x4jEYO1CSAsVMRvOSIJOnJ6SoVHyfHx9Ymac1izvHWZrWZFWZXISwbLOFzTkKsVVsnkMJL4ue+Ac9DU9DgOhBDhjx2aF5i7B6bmjqkt0545Iu5U0A+SnIzwUiYRS3lpIf7EJYREXddo2xaOBPdZwYyC0MPoPj1nZjNgNaMM73hmHxHJhaMM7TwjrCYN6ux7qK6DpyGFM8Dt5v0nXxlWjwpVVb/u30/vei8HTX9DgXGk6YfwEvyLH+BaHJuOgKywAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/6e3acdce9b6b407da6e5a9e623787042/0b533/4hand.png&quot;
        srcset=&quot;/neekoblog/static/6e3acdce9b6b407da6e5a9e623787042/fac75/4hand.png 125w,
/neekoblog/static/6e3acdce9b6b407da6e5a9e623787042/63868/4hand.png 250w,
/neekoblog/static/6e3acdce9b6b407da6e5a9e623787042/0b533/4hand.png 500w,
/neekoblog/static/6e3acdce9b6b407da6e5a9e623787042/1d69c/4hand.png 750w,
/neekoblog/static/6e3acdce9b6b407da6e5a9e623787042/612f7/4hand.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이것도 송신측과 수신측이&lt;br&gt;
&quot;나 이제 다 보냈어&quot;=&gt; &quot;오케 닫을게&quot;, &quot;닫았어&quot; =&gt; &quot;나도 닫을게&quot; 이렇게 주고 받는다고 이해하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TCP- 응용 계층&lt;/em&gt;
응용 프로그램들이 네트워크를 이용할 수 있게 암호화, 사용자 인증을 수행하는 역할이다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이상으로 TCP와 OSI 7 Layer등 프로토콜과 모델에대해 살펴보았다.&lt;/p&gt;
&lt;p&gt;CS 측면에서 모뎀이 무엇인지, HUB가 무엇인지 등을 더 자세히 살펴 볼 필요가 있다.&lt;/p&gt;
&lt;p&gt;그리고 TCP 통신과 브라우저 작동과도 연계가 되어있는데&lt;/p&gt;
&lt;p&gt;이 부분에 대해서 추후에 리포팅 하겠다.&lt;/p&gt;
&lt;p&gt;참고로 같은 내용을 네이버 블로그에서도 다루는 중이다.
&lt;a href=&quot;https://blog.naver.com/neeko_k/223590184796&quot;&gt;https://blog.naver.com/neeko_k/223590184796&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[웹 표준과 웹 호환성]]></title><description><![CDATA[웹 표준이란?  여러 국제 표준 기구가 정한 규칙 웹 표준은 웹의 사용성과 접근성을 극대화 하도록 조정된다. 종류 IETF(Internet Engineering Task Force) : URI, HTTP 등 설정과 사용에 대한 표준 (STD) W3C…]]></description><link>https://yeaseul7.github.io/neekoblog/w3cAndWebSustain/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/w3cAndWebSustain/</guid><pubDate>Thu, 05 Sep 2024 12:40:56 GMT</pubDate><content:encoded>&lt;h3&gt;웹 표준이란?&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 288px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/eff64b05d033fe93741e6e899849695d/c14c5/browsers.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.8%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMCBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHZWyI2AE//xAAaEAACAgMAAAAAAAAAAAAAAAABAgADERIT/9oACAEBAAEFArCYC20Nal+K4n//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAwEBPwGn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAAcBAAAAAAAAAAAAAAAAAAECEBESIUH/2gAIAQEABj8ChB6JNZVa/RGt/8QAGxABAQEAAgMAAAAAAAAAAAAAAREAEFExgeH/2gAIAQEAAT8hhAGyZoiHfAlWDvfUesEIeN//2gAMAwEAAgADAAAAEHMP/8QAFxEBAQEBAAAAAAAAAAAAAAAAAREQMf/aAAgBAwEBPxACLzP/xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQIBAT8QoX//xAAdEAEBAAICAwEAAAAAAAAAAAABEQAhMYFRkaHB/9oACAEBAAE/ELyRqKWR/cHIKgRjb55+YbMP/TBweu8bRArs2iKPTgEEBAz/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/eff64b05d033fe93741e6e899849695d/c14c5/browsers.jpg&quot;
        srcset=&quot;/neekoblog/static/eff64b05d033fe93741e6e899849695d/aa2ed/browsers.jpg 125w,
/neekoblog/static/eff64b05d033fe93741e6e899849695d/0479a/browsers.jpg 250w,
/neekoblog/static/eff64b05d033fe93741e6e899849695d/c14c5/browsers.jpg 288w&quot;
        sizes=&quot;(max-width: 288px) 100vw, 288px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여러 국제 표준 기구가 정한 규칙&lt;/p&gt;
&lt;p&gt;웹 표준은 웹의 사용성과 접근성을 극대화 하도록 조정된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;종류&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IETF(Internet Engineering Task Force) : URI, HTTP 등 설정과 사용에 대한 표준 &lt;strong&gt;(STD)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;W3C : 마크업 언어에 대한 명세 (HTML, XHTML, SVG, CSS 등)&lt;/li&gt;
&lt;li&gt;Ecma : 스크립팅 표준&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;웹 표준이 없던 1990년대 말 쯤에는 표준이 없어서 브라우저마다 사이트를 만들어야 했다. (Explore, 넷스케이프)&lt;/p&gt;
&lt;p&gt;웹표준을 지켜서 개발하면 크롤러가 나의 사이트의 구조와 콘텐츠를 더 명확하게 이해할 수 있다. &lt;strong&gt;(SEO 최적화)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3.org/standards/&quot;&gt;웹표준&lt;/a&gt;은 여기서 확인할 수 있다.&lt;/p&gt;
&lt;h3&gt;웹 접근성이 무엇인가요?&lt;/h3&gt;
&lt;p&gt;웹 표준은 웹 접근성, 사생활 보호, 보안, 국제화의 측면에서 고려되어야 한다고 한다.
그 중 웹 접근성은 장애를 가진 사람과 가지지 않은 사람 모두가 웹사이트를 이용할 수 있게 한다는 것을 의미 한다.&lt;/p&gt;
&lt;p&gt;예를들어 시각장애인은 &apos;스크린 리더&apos;라는 것을 이용해서 웹페이지 내용을 파악하는데
스크린 리더가 읽을 수 있게 이미지만 올려놓는게 아닌 alt 등으로 설명을 추가해야한다.
이게 웹 접근성을 고려한 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img arc = &quot;img/login.png&quot; alt=&quot;로그인 /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;출처: &lt;a href=&quot;https://goddaehee.tistory.com/244&quot;&gt;https://goddaehee.tistory.com/244&lt;/a&gt; [갓대희의 작은공간:티스토리]&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[크로스 브라우징 그리고 렌더링 엔진]]></title><description><![CDATA[웹 호환성과 웹 표준에 대해서 공부하다가 웹 호환성 테스트를 위해 크로스 브라우징 테스트라는게 있는지 알았고 Babel과 polyfill…]]></description><link>https://yeaseul7.github.io/neekoblog/crossbrowsing/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/crossbrowsing/</guid><pubDate>Thu, 05 Sep 2024 12:40:56 GMT</pubDate><content:encoded>&lt;p&gt;웹 호환성과 웹 표준에 대해서 공부하다가&lt;br&gt;
웹 호환성 테스트를 위해 크로스 브라우징 테스트라는게 있는지 알았고&lt;br&gt;
Babel과 polyfill로 구현한다는 것을 알았다.&lt;/p&gt;
&lt;p&gt;이후에 브라우저가 어떻게 동작하길래 이런 호환성을 맞추는 과정이 필요한지 궁금해서&lt;br&gt;
렌더링 엔진 및 브라우저 엔진에 대해 살펴보게 되었다.&lt;/p&gt;
&lt;h3&gt;크로스 브라우징이란?&lt;/h3&gt;
&lt;p&gt;웹 호환성을 구현하기 위한 기술이다.&lt;/p&gt;
&lt;p&gt;호환성을 확인하기 위해서는 &lt;a href=&quot;https://caniuse.com/&quot;&gt;https://caniuse.com/&lt;/a&gt; 에서 확인해볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;여담인데 MS가 IE11보다 오래된 IE는 지원을 중지했고 사용해도 Edge로 사용을 전환할것을 요구한다고 한다.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;렌더링 엔진이란?&lt;/h3&gt;
&lt;p&gt;화면에 text와 image를 그리는 software이다.&lt;br&gt;
HTML,XML,CSS 등 소스 코드를 호출시에 읽고 해석하는 인터프리터이다.&lt;/p&gt;
&lt;p&gt;렌더링 엔진은 그릴 때 웹 표준에 따라 보안정책을 강제하며 script에 노출되는 DOM 자료구조를 구현한다.&lt;/p&gt;
&lt;p&gt;여기서 보안정책은 사이트 간 스크립팅(XSS), 클릭재킹, 코드 인젝션을 방지한 컴퓨터 보안수준이다.&lt;br&gt;
이는 W3C에서 규정하고 있다.&lt;/p&gt;
&lt;h4&gt;렌더링 엔진 동작 과정&lt;/h4&gt;
&lt;p&gt;URL을 입력하면 8KB 단위로 문서의 내용이 전달된다.
이후 아래의 단계로 작업이 진행된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM 트리 구축을 위한 HTML 파싱&lt;/li&gt;
&lt;li&gt;렌더 트리 구축&lt;/li&gt;
&lt;li&gt;렌더 트리 배치&lt;/li&gt;
&lt;li&gt;렌더 트리 그리기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/0094f00c71f8acfd95f7a28b815dde37/612f7/render.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 17.6%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxElEQVR42n2P2U7DMBBF8/8fxwNSeQFRAd1oYjuxndgeuzmdFB4RVxrNneXO0vGL223Fx8ToF+ZcmWJhComYmvKM8z88LKJ9Gakrf6F7DGuNJQu71y+eXt45m8Th2/N5Grg44dgHPk6Gq2/qLW/7I1YXiBSKCKWUh9Va6dZVL/Meaw37i+X5MDIngZLZbmhVGMPMdYykJTI6h+l7nLNYY3BmoNfYKN/mdG5LanGaJk0OylUwGILGG0oRYggEtU3Q9Jv/cAdanzS6XEj38wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/0094f00c71f8acfd95f7a28b815dde37/0b533/render.png&quot;
        srcset=&quot;/neekoblog/static/0094f00c71f8acfd95f7a28b815dde37/fac75/render.png 125w,
/neekoblog/static/0094f00c71f8acfd95f7a28b815dde37/63868/render.png 250w,
/neekoblog/static/0094f00c71f8acfd95f7a28b815dde37/0b533/render.png 500w,
/neekoblog/static/0094f00c71f8acfd95f7a28b815dde37/1d69c/render.png 750w,
/neekoblog/static/0094f00c71f8acfd95f7a28b815dde37/612f7/render.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 렌더링 엔진은 모든 HTML을 파싱(분석)할 때까지 기다리지 않고 배치와 그리기 과정을 반복한다.&lt;br&gt;
즉, 모든 내용을 받기 전 일부 내용을 화면에 표시한다.&lt;/p&gt;
&lt;h4&gt;렌더링 엔진의 종류&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/50b92797d9915397e9d9dc9e83d996dd/612f7/renderingEngine.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 66.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACdUlEQVR42m2SC0vcUBCF88/7E4pQaLUPFIugUEXaWii2aHVXXaVFq0VjsnlsXjfvbJ67m+R0cl1aFS98mcydm8O5kxF834eqqvC8ANWkRts0aJoWbXtHQ3n7mPZ/va6bf3RnBeYGCMIYaZpBMxiiJEccJwijhEeepxUnySpE45LXgiCiGKMoK5TVhFNNphBsP8OtYsALQshGAkk1MFRUyEMVijaivRjyKICkmIQF3fTA/AA2c8E8H+MsR1aUnE5cYH4KWfeRZgWGRghJYxAlGTeiiFtJhWanGDkpDCfmOHTeiytiAi8q4foRLC+H7mQIkxKCF6ZQRy4VAqi6DlnRuTtJlsmhBcP24TDG626Qw7Q9mA6JsBAj0+QOi3JCDisUdG2BBSVUM+T9UIwIt6pNzkhM1ehKAfw4h+N6JOoiTlLk9GGal0TB6YTy8g4u6AQFxKHJe9LZVg0XiqJxwaGmk2sLKsUuHxkmGIl3/crnZPfgPRznU7hhifE4haQnJO7h+kaiPtJPGFrUSwWiKOP6WqQpCKkFCbkNYVs2d21S7LBsB0laUA9pDrs/XLVAPiejmUrrGfKmRkozmRFdPqW5mwGoO/gM1g/msMuFJInBmIP8aIB2/wDtjx5xSPTvvd/lONwDet/Qft9FS1PAFwnfX8J0NgNzLOxvHmFzsYdPy8f4vDx4yMqA9k8p/sTBxgCX21/hX10+LTgjQdu2cXZxjq2dj1haXcHz16+w8GaRWJrHRTxfeolnC+/wYmMPazu7+PXnaq73SLB7xHGMi/NzXP2+xOnZGQ57ffT6/Xk8wsnJANs7X7D2YQPrW+t4+34Vx3TuKcG/2wy/XNolWXYAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/50b92797d9915397e9d9dc9e83d996dd/0b533/renderingEngine.png&quot;
        srcset=&quot;/neekoblog/static/50b92797d9915397e9d9dc9e83d996dd/fac75/renderingEngine.png 125w,
/neekoblog/static/50b92797d9915397e9d9dc9e83d996dd/63868/renderingEngine.png 250w,
/neekoblog/static/50b92797d9915397e9d9dc9e83d996dd/0b533/renderingEngine.png 500w,
/neekoblog/static/50b92797d9915397e9d9dc9e83d996dd/1d69c/renderingEngine.png 750w,
/neekoblog/static/50b92797d9915397e9d9dc9e83d996dd/612f7/renderingEngine.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이중에서 Webkit과 Gecko의 동작 과정은 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/4cc1e9a29c014e3882fdf6a4a4d093fa/612f7/rendering.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABmUlEQVR42o2SWW7bMBRFvfUuoGvoOvrRvwIF0iIeEmewLVuKJWukPGikROqUkQA3QTOYAEWBeO/yDm/EBavrhjPaCezljo7hojtX6PPf6AOY/tu2S47ZikPVEUYx261H3nRkVftm12hg0L3aL1+tyh/skp9sIslifcfGuWcdCdZBSC41eX1CtRPTV37G8J/c/olOsxrfsJg+EAoHcfCxRIuXrinLLyjlDYBaKeIwJDTb932CIEBKaaTWfcH+8JWV+435U4XnzIiOHo1smYwnzKYTqqp8LVkZQMe2cRwH13WxLIvAACdpSpukNME1TWKhjH+12NM0z7ZoiqIgz3O0VpeGQt+otR7KM8HRMkqeisFh3f0X4AehDAWqsXGTK8a2x+zXFXNnwqa0DEvNH3NXyObtlN+naLxUkqLWVKcTnWpYxim/ty7zdM7Uj/HTO3R7f2b66RyWhUUaf8dJM/xc8GD83KV7TvKAyEuyUqDV4fLBbozssrjGTjLs4w7Rhshacntzy+LxsZ+IyyW/s7Txuaoq6rruQ3sJ+BeYTaKePepH3QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/4cc1e9a29c014e3882fdf6a4a4d093fa/0b533/rendering.png&quot;
        srcset=&quot;/neekoblog/static/4cc1e9a29c014e3882fdf6a4a4d093fa/fac75/rendering.png 125w,
/neekoblog/static/4cc1e9a29c014e3882fdf6a4a4d093fa/63868/rendering.png 250w,
/neekoblog/static/4cc1e9a29c014e3882fdf6a4a4d093fa/0b533/rendering.png 500w,
/neekoblog/static/4cc1e9a29c014e3882fdf6a4a4d093fa/1d69c/rendering.png 750w,
/neekoblog/static/4cc1e9a29c014e3882fdf6a4a4d093fa/612f7/rendering.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DOM 구축과 렌더트리를 그리는 과정을 더 자세히 볼 수 있다.&lt;/p&gt;
&lt;p&gt;파싱이라는 말이 자주 나오는데&lt;br&gt;
파싱도 공부하면 엄청 심오하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;파싱은 구문석이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;즉, 문서 파싱은 렌더링 측면에서 브라우저가 코드를 이해하고 사용할 수 있는 구조로 만드는 것을 의미한다.&lt;br&gt;
크게 두가지로 나눌 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;어휘 분석&lt;/li&gt;
&lt;li&gt;구문 분석&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;어휘분석&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자료를 토큰으로 분해한 것이다.&lt;br&gt;
토근은 공백과 줄바꿈 같은 의미 없는 문자를 제거한 유효하게 구성된 단위의 집합체이다.&lt;br&gt;
예를 들면 용어집이라고 생각할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;구문 분석&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;언어의 구문 규칙을 적용하는 과정이다.&lt;/p&gt;
&lt;p&gt;파싱 과정을 아래와 같이 설명할 수 있다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/8c97b9fbd5d88073216b118eaad286a8/612f7/parse.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.4%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABR0lEQVR42p2Sv0vDQBiG+wc7uvkfKIgOHVyKk4ubi4MoHYRWaRGFSh1SGiHRpmmSXtJrrpfcY/qLFqq19IMXjvs+nnvv7i2xpYwBqXJiqUknhl2qtAXHRBvq7ZT7ZoTt5bM9Y/YAmoW7qQYio/sVo7N83szzVZN1/QI0xVC+sBCJGMvpFbCIxruPSBQoOZvZ2eFydPpcZ6+Kk6ak+iGotQKCroO6OCW9uYZxAY5CTCzmGg4hyzaBSTJCFgPOIOboOaVigT2Y0HFjRMcmvSwjy8cwSjCBP4eGwWyNnmwCoyjC8zxCv0/lTXDYgJolua1982kHYLXJ5WgVgb+uLEThynFwXRfhuTzagoM6PLiFmeKn+2FClpsV6DetA7XWKKVIpSRTKYnKuOoYzltQfelz9+QQj80iNmbfHBYHZQbH1/RCzTI1/wX7BxuCBs7wQ5QoAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/8c97b9fbd5d88073216b118eaad286a8/0b533/parse.png&quot;
        srcset=&quot;/neekoblog/static/8c97b9fbd5d88073216b118eaad286a8/fac75/parse.png 125w,
/neekoblog/static/8c97b9fbd5d88073216b118eaad286a8/63868/parse.png 250w,
/neekoblog/static/8c97b9fbd5d88073216b118eaad286a8/0b533/parse.png 500w,
/neekoblog/static/8c97b9fbd5d88073216b118eaad286a8/1d69c/parse.png 750w,
/neekoblog/static/8c97b9fbd5d88073216b118eaad286a8/612f7/parse.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;파싱 트리를 만들고 컴파일러가 기계 코드 문서로 변환하는 과정을 거친다.&lt;br&gt;
이 과정에서 &lt;strong&gt;문맥 자유 문법&lt;/strong&gt;을 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;문맥 자유 문법은 컴파일러 설계나 자연어 처리할 때 언어의 구문을 기술하는데 활용되는 문법이다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;간단히 파싱이 뭔지 알았으니&lt;br&gt;
이렇게 파싱이 트리를 구성하고 DOM 트리나 콘텐츠 모델이 완성되는 과정을 더 자세히 이해했을 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;네이버 Dev 문서를 적극 차용해서 작성된 글이다.&lt;br&gt;
파싱에 대한 내용이 많아서 그 부분은 따로 포스팅을 작성하려고 한다.&lt;br&gt;
오늘 포스팅을 위해 문서와 다양한 참고 자료를 3일동안 중간 중간 몇번이나 읽어보고 그곳의 이미지를 차용해 내가 이해한 내용을 붙여서 작성하였다.
&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;https://d2.naver.com/helloworld/59361&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[DOM과 VDOM]]></title><description><![CDATA[DOM이란? Document Object Model HTML, XML 문서의 프로그래밍 interface다. DOM의 element는 object로 구성되어있다. interface…]]></description><link>https://yeaseul7.github.io/neekoblog/dom-vdom/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/dom-vdom/</guid><pubDate>Mon, 02 Sep 2024 12:40:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/612f7/domtree.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 83.2%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQklEQVR42pVSTW/TQBDNv+LAP+MM96JeWlVCQpUQAioh9ZBCD6RR+klpiJM4cYLjXXv9sU52vXbirLOJbTZ201IqVfBkWzPzZubNeLeCMZ5Op+EGURTN5/O4QGlsvFhSjDGZI7/ShRBWOOd5nmdZlheQLgDA932EkGmaTgHbtl3Xlb3KzDKZUlq5C6VpKg3Z+Pr6ut/rdTrdq6urlqKcX1w0m01FUaSgTEgLSIMQcl+c36Gwp5buH+yg99v07OguuOEfKd9zaSqd2LXh4Sft4B25uczK4CbnqWLpyXe5DLHXcKxvCQfZJvgPytl6pQk6Gdaeq8fPkPKinOc/imfxRNOr6uDQn3QfJTwsLqeSwXRNZJnI+rj7wX27b+zV8FfBRfGfbzs8pTyPZwFl48gfhG0taJlMZzRI+PwJ5TxOFjab/RyOoIvzh+ALoehgYGMy438Xl7P0x+FWy37V6H8xWXk08jKs1vch0yeScl7W1c8GXTPFJXmgPI6iSx3WVW3gYbFI/lwkFqJP2Plw1LO91XJ5r8xoxPz4l2r6ti/CBKiQeeEYEzBASMdTKufMxHxFTOLq7pIvHAsPuzAOhOf4leEPt7YDjreHas1rH42rr7WzfdvqBPU3oLrV+/7RyfNVv0ZOdq3TPc8zIv2CNHbdm33WPjUqxGPMEgFcMByHHg+goCafBZxCHpiCIrlUFvqcgoQYCZ+J6YQTg0dohYBX0Qaa5UCIRtAC6wcZEAFgSuPWNgxjEzcABNAEwBrZnqW0W78B5qe08dPiof8AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/0b533/domtree.png&quot;
        srcset=&quot;/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/fac75/domtree.png 125w,
/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/63868/domtree.png 250w,
/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/0b533/domtree.png 500w,
/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/1d69c/domtree.png 750w,
/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/612f7/domtree.png 773w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;DOM이란?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Document Object Model&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML, XML 문서의 프로그래밍 interface다.&lt;br&gt;
DOM의 element는 object로 구성되어있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;interface란?&lt;/em&gt;
&lt;em&gt;사용자가 상호작용 할 수 있게 하는 프로그래밍 인터페이스이다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;즉, DOM은 동적 콘텐츠를 제공하며 사용자로 하여금 상호작용할 수 있게 한다.&lt;/p&gt;
&lt;p&gt;DOM이 있기 때문에 javascript와 같은 script언어로 문서의 구조, 스타일 등을 조작할 수 있다.&lt;/p&gt;
&lt;p&gt;DOM중에서 최상위에 있는 Document object는 document(웹페이지) 그 자체이다.&lt;br&gt;
page content는 DOM에 저장되는데 이걸 script언어로 조작할 수 있다.&lt;/p&gt;
&lt;p&gt;DOM API는 DOM을 script 언어로 조작할 수 있도록 제공되는 일련의 인터페이스이다.&lt;br&gt;
이것을 이용해서 동적으로 element를 조작할 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;그렇다면 React의 Virtual Dom은 무엇인가?&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/bc514/Dom.webp&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRloAAABXRUJQVlA4IE4AAAAQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJaQAAetFIHAAA/vFBZnfxO7A6e8LQjz+ZjrRKgNBiydWOH2Sfv9yAgxNETQPllnhbPpuAAAA=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/b0a15/Dom.webp&quot;
        srcset=&quot;/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/42aaf/Dom.webp 125w,
/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/1e0be/Dom.webp 250w,
/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/b0a15/Dom.webp 500w,
/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/bc514/Dom.webp 720w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Virtual Dom은 &lt;strong&gt;DOM 복사본&lt;/strong&gt;이다.&lt;br&gt;
이는 실제 DOM이 아닌 JS 객체 형태로 메모리에 저장된다.&lt;/p&gt;
&lt;p&gt;VDOM을 통해서 실제 DOM에는 접근할 수 없다. (VDOM을 수정해서 업데이트 한다.)&lt;br&gt;
VDOM을 수정하는 것은 메모리에 저장되어있는 JS 객체를 수정하는 것이기 때문에 비교적 가볍다.&lt;/p&gt;
&lt;p&gt;VDOM없이 DOM을 조작할 때 스타일을 추가하거나 하면&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;querySelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;#title&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;style&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;color &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;document에서 해당 element를 탐색해서 찾는다.&lt;/li&gt;
&lt;li&gt;해당 element와 그 자식 element들을 DOM에서 제거한다.&lt;/li&gt;
&lt;li&gt;수정된 Element로 교체한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 과정에서 브라우저의 Reflow와 Repaint를 유발한다.&lt;br&gt;
단순히 조금만 수정한다면 문제는 없지만 사이트가 거대해질수록 위의 작업이 반복적으로 일어난다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;React는 VDOM을 이용해서 어떻게 효율적으로 랜더링하나?&lt;/h3&gt;
&lt;p&gt;React에서는&lt;br&gt;
&lt;strong&gt;랜더링 이전 구조를 나타내는 VDOM&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;랜더링 이후에 보일 구조를 나타내는 VDOM&lt;/strong&gt;이 존재한다.&lt;/p&gt;
&lt;p&gt;React에서는 State가 변경될 때마다 Re-Rendering이 발생하면서 &lt;strong&gt;랜더링 이후에 보일 구조를 나타내는 VDOM&lt;/strong&gt;을 생성한다.&lt;br&gt;
그러면 React는 이 두개의 VDOM을 비교해서 어떤 Element가 바뀌었는지 비교한다. &lt;strong&gt;(Diffing)&lt;/strong&gt;&lt;br&gt;
실제로 바뀐 부분만 실제 DOM에 적용한다. &lt;strong&gt;(Reconciliation)&lt;/strong&gt;&lt;br&gt;
변경된 모든 내용을 집단화시켜서 한번에 실제 DOM에 적용하는 과정을 거친다. &lt;strong&gt;(Batch Update)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;따라서 훨씬 효율적인 랜더링을 할 수 있다.&lt;/p&gt;
&lt;p&gt;참고자료 : &lt;a href=&quot;https://callmedevmomo.medium.com/virtual-dom-react-%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC-bfbfcecc4fbb&quot;&gt;https://callmedevmomo.medium.com/virtual-dom-react-%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC-bfbfcecc4fbb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;사진 출처 : &lt;a href=&quot;https://medium.com/@surksha8/virtual-dom-and-real-dom-understanding-the-differences-da8f3fab4261&quot;&gt;https://medium.com/@surksha8/virtual-dom-and-real-dom-understanding-the-differences-da8f3fab4261&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freecodecamp.org/news/introduction-to-the-dom/&quot;&gt;https://www.freecodecamp.org/news/introduction-to-the-dom/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SSR과 CSR의 차이]]></title><description><![CDATA[SSR application 형성 과정 SSR 애플리케이션은 화면을 그릴 때 서버에 HTTP 요청으로 데이터를 받아와서 HTML 파일을 클라이언트로 전송한다. SSR서버와 클라이언트가 어느단계로 작동하는가? 브라우저가 특정 URL에 대해 HTML…]]></description><link>https://yeaseul7.github.io/neekoblog/ssr-server/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/ssr-server/</guid><pubDate>Wed, 28 Aug 2024 12:40:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/bc514/ssr.webp&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 71.2%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRqIAAABXRUJQVlA4IJYAAAAwBACdASoUAA4APtFUo0uoJKMhsAgBABoJQBOmUGRZlPAce2D6MF9TQcAA/vYeGWc4U5rLgSqyzojYAvHxTrSkQ9V1bumaP2TUXBUSS4h40pas9VwypPKOCSysqQ6IpSG4LEwhQe5272g2e+8SF/v7B/7G2ISkv2K35nQtZp0pXBwkVrJhscHhT5zw6jPWibkCM0Q/gAA=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/b0a15/ssr.webp&quot;
        srcset=&quot;/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/42aaf/ssr.webp 125w,
/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/1e0be/ssr.webp 250w,
/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/b0a15/ssr.webp 500w,
/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/bc514/ssr.webp 720w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;SSR application 형성 과정&lt;/h3&gt;
&lt;p&gt;SSR 애플리케이션은 화면을 그릴 때 서버에 HTTP 요청으로 데이터를 받아와서 HTML 파일을 클라이언트로 전송한다.&lt;/p&gt;
&lt;p&gt;SSR서버와 클라이언트가 어느단계로 작동하는가?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;브라우저가 특정 URL에 대해 HTML 파일을 SSR 서버로 요청한다.&lt;/li&gt;
&lt;li&gt;SSR 서버가 모든 요청받은 데이터를 가지고 HTML 파일을 반환한다.&lt;/li&gt;
&lt;li&gt;클라이언트에서 유저가 볼 수 있는 페이지를 랜딩한다. [초기 로딩 상태로 표시]&lt;/li&gt;
&lt;li&gt;클라이언트에서 VDOM을 붙이거나 이벤트들을 붙인다.(Hydration 과정)&lt;/li&gt;
&lt;li&gt;사용할 수 있는 화면이 완성된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;내가 프로젝트에서 Next.js를 사용하는 이유&lt;/h3&gt;
&lt;p&gt;나는 프로젝트를 할 때 보통 react를 사용한다.&lt;br&gt;
react가 생태계가 넓어서 학습하기에 좋다고 생각하기 때문이다.&lt;/p&gt;
&lt;p&gt;&apos;에브리 멍멍&apos;이라는 프로젝트를 진행 할 때 Next.js도 사용하게 되었다.&lt;br&gt;
Next.js는 SSR과 SSG를 지원함으로 서버에서 랜더링 된 HTML이 검색 엔진 크롤러가 콘텐츠를 쉽게 읽을 수 있다.&lt;br&gt;
또한 Next.js의 app router로 인해 페이지를 구성하는게 유리했다.&lt;br&gt;
작업의 편리성과 SEO를 고려해 Next.js를 선택하게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/fba964d42a47fe373f6cea775862a749/bc514/csr.webp&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.2%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRpgAAABXRUJQVlA4IIwAAAAwBACdASoUAA8APtFUo0uoJKMhsAgBABoJQBAAlf8WvC325j0sMsJ14AAA/vYJraw0gBdyEbMfO9LoMfGGbIgwGO3Rhz6O/+PqVDY4iE0EmIytWa51ECtI5k6KICYfzXfIYs9cqs5AzmtnG5PZjZ6cWIZTlTbQNbvqbLwqIGmUTJmBdEdppb5WO8AAAA==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/fba964d42a47fe373f6cea775862a749/b0a15/csr.webp&quot;
        srcset=&quot;/neekoblog/static/fba964d42a47fe373f6cea775862a749/42aaf/csr.webp 125w,
/neekoblog/static/fba964d42a47fe373f6cea775862a749/1e0be/csr.webp 250w,
/neekoblog/static/fba964d42a47fe373f6cea775862a749/b0a15/csr.webp 500w,
/neekoblog/static/fba964d42a47fe373f6cea775862a749/bc514/csr.webp 720w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;그렇다면 SSR과 CSR의 차이점은 무엇일까?&lt;/h4&gt;
&lt;p&gt;최초의 DOM tree가 어디서 생성되느냐에 따라 구분지었다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;CSR은 서버가 html파일을 가지고 오는것이 아니고 javascript 파일을 가지고 와서 화면을 그리는 방식인데&lt;br&gt;
클라이언트가 빈 HTML에 서버에서 받아온 js파일을 이용해서 DOM tree를 형성하는 것이라고 볼 수 있다.&lt;br&gt;
(그러면 초기 랜더링 속도가 아무래도 오래걸릴 것이다.)&lt;/p&gt;
&lt;p&gt;결론은 CSR은 클라이언트(브라우저)에서 DOM이 형성된다.&lt;/p&gt;
&lt;p&gt;반면 SSR은 서버에서 html 파일을 가지고 온다.&lt;br&gt;
서버에서 html을 가지고 오기 때문에 서버에서 DOM이 형성된다고 볼 수 있다.&lt;/p&gt;
&lt;h3&gt;SEO와 SSR그리고 CSR&lt;/h3&gt;
&lt;p&gt;위에서 SEO를 고려해서 Next.js를 선택했다고 했는데,&lt;br&gt;
SEO를 위해서는 구글 봇이 나의 웹페이지를 잘 읽어야 한다.&lt;br&gt;
CSR로 되어있으면 랜더링 하는 과정과 그걸 해석하는 시간이 필요하다.&lt;br&gt;
그래서 더 복잡하고 시간이 걸릴 수 있다.&lt;br&gt;
게다가 javascript를 해석하는데에 제한이 있어서 그 점을 고려해야한다.&lt;/p&gt;
&lt;p&gt;반면 SSR은 html이 미리 랜더링 되어있기 떄문에 크롤러가 해석하는데 시간도 단축되고 더 심플하다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;모든 경우에 SSR이 유리한 것은 아니다.&lt;/em&gt;&lt;br&gt;
Google Bot의 크롤링 방식을 보다 잘 이해하고 어떤 것이 제한적이며 랜더링 최적화 과정을 거친다면 못지 않은 SEO를 구축할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSR에서는 치명적인 단점이 존재한다.&lt;/strong&gt;&lt;br&gt;
서버에서 html이 완성되어 전달되기 때문에 동적인 컨텐츠를 표시하기 힘들다.&lt;br&gt;
때문에 클라이언트측에서 실행되는 js 파일을 추가해서 동적인 컨텐츠를 다룰 수 있다.&lt;/p&gt;
&lt;p&gt;Next.js에서 SSR와 CSR 개념을 결합해서 사용하는 Server-component, Client-compoenent 개념과 밀접한 관련이 있다.&lt;/p&gt;
&lt;h3&gt;SSR Hydration&lt;/h3&gt;
&lt;p&gt;서버에서 html 파일을 완성된 형태로 가지고 오니까 초기 랜더링 속도가 SSR이 &lt;strong&gt;무조건&lt;/strong&gt; 압도적으로 빠른건가?&lt;br&gt;
&lt;strong&gt;아니다&lt;/strong&gt;&lt;br&gt;
SSR에서 완성된 Dom tree를 가지고 온다고 해도 동적인 콘텐츠를 가지기 위해서는 Hydration이라는 작업이 필요하다.&lt;br&gt;
결국 이 모든 과정이 끝나야 페이지를 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;제대로 비교하기 위해서는 초기 HTML에 내용이 어느정도 포함되어 있는지와 Hydration 과정이 얼마나 복잡한지 고려해야한다.&lt;/p&gt;
&lt;p&gt;사진 출처 : &lt;a href=&quot;https://medium.com/@derekvogt3/csr-ssr-vs-ssg-87b112370db&quot;&gt;https://medium.com/@derekvogt3/csr-ssr-vs-ssg-87b112370db&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Memoization]]></title><link>https://yeaseul7.github.io/neekoblog/memoization/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/memoization/</guid><pubDate>Tue, 20 Aug 2024 12:40:56 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[네트워크란?]]></title><description><![CDATA[네트워크가 뭐에요? 
네트워크는 두대 이상의 컴퓨터에서 데이터나 정보를 공유하기 위해 존재한다.
(두대 이상의 노드에서 데이터나 정보를 공유하기 위해 존재한다.) 네트워크의 종류는 크게 두가지로 볼 수 있다.
WAN과 LAN이 존재하는데 Wide…]]></description><link>https://yeaseul7.github.io/neekoblog/network/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/network/</guid><pubDate>Mon, 19 Aug 2024 12:34:56 GMT</pubDate><content:encoded>&lt;h3&gt;네트워크가 뭐에요?&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 259px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/9245782c13c83be6990a81ef0184bb76/8356d/network.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.2%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHsS0SQccK//8QAGxAAAgMAAwAAAAAAAAAAAAAAAQIAERIDEyL/2gAIAQEAAQUC7Bacmyr3M+kEUED/xAAXEQADAQAAAAAAAAAAAAAAAAABEBES/9oACAEDAQE/ATqr/8QAFREBAQAAAAAAAAAAAAAAAAAAECH/2gAIAQIBAT8Bh//EABsQAAMAAgMAAAAAAAAAAAAAAAABESExAhJB/9oACAEBAAY/AnnQ1TZfBzj1Mun/xAAaEAEBAQEBAQEAAAAAAAAAAAABEQAhMUFR/9oACAEBAAE/IfKEPSd3dw3lMAeWM8y1pKJJjsq+Okb/ANm//9oADAMBAAIAAwAAABAT3//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8QSEeCP//EABcRAQEBAQAAAAAAAAAAAAAAAAEAETH/2gAIAQIBAT8QHDvZv//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExYUGBwf/aAAgBAQABPxBr9UdWenio+jrCVW+yb9ESI4lSGFXads8pADT9g5odE//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/9245782c13c83be6990a81ef0184bb76/8356d/network.jpg&quot;
        srcset=&quot;/neekoblog/static/9245782c13c83be6990a81ef0184bb76/aa2ed/network.jpg 125w,
/neekoblog/static/9245782c13c83be6990a81ef0184bb76/0479a/network.jpg 250w,
/neekoblog/static/9245782c13c83be6990a81ef0184bb76/8356d/network.jpg 259w&quot;
        sizes=&quot;(max-width: 259px) 100vw, 259px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
네트워크는 두대 이상의 컴퓨터에서 데이터나 정보를 공유하기 위해 존재한다.&lt;br /&gt;
(두대 이상의 노드에서 데이터나 정보를 공유하기 위해 존재한다.)&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;네트워크의 종류는 크게 두가지로 볼 수 있다.&lt;br /&gt;
WAN과 LAN이 존재하는데 &lt;em&gt;Wide Area NerWork&lt;/em&gt;와 &lt;em&gt;Local Area Network&lt;/em&gt;의 축약어로 해석 그대로&lt;br /&gt;
&lt;strong&gt;광역 통신망&lt;/strong&gt; 과 &lt;strong&gt;근거리 통신망&lt;/strong&gt;이라고 불린다.&lt;br /&gt;
LAN은 근거리 통신망으로 사내에서 사용하는 네트워크를 예로 들 수 있다.&lt;br /&gt;
WAN은 우리가 보통 사용하는 해외사람들이랑 소통하기 위해 존재하는 네트워크라고 생각할 수 있다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 261px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/efaf08808eb19eca3435cc95fcf710c0/677e6/networkKind.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 73.6%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAACAf/aAAwDAQACEAMQAAAB6+Tzs3iBv//EABkQAQEBAAMAAAAAAAAAAAAAAAIBAAMTIf/aAAgBAQABBQJ8km7NFMzZgkkR5//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/Aaf/xAAWEQEBAQAAAAAAAAAAAAAAAAAAESH/2gAIAQIBAT8BjH//xAAYEAEBAQEBAAAAAAAAAAAAAAABACEQEf/aAAgBAQAGPwLqm3iW3//EABoQAAMAAwEAAAAAAAAAAAAAAAABESExQVH/2gAIAQEAAT8hkIlbQ0vCKNMEoGukYbJ//9oADAMBAAIAAwAAABAQP//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8QbWGn/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAECAQE/EAJpJP/EABwQAQADAAIDAAAAAAAAAAAAAAEAESExUYGhwf/aAAgBAQABPxBGgS+VfkU4G0WJBatoIcuyqgbWcIV72U/gJ//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Network이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/efaf08808eb19eca3435cc95fcf710c0/677e6/networkKind.jpg&quot;
        srcset=&quot;/neekoblog/static/efaf08808eb19eca3435cc95fcf710c0/aa2ed/networkKind.jpg 125w,
/neekoblog/static/efaf08808eb19eca3435cc95fcf710c0/0479a/networkKind.jpg 250w,
/neekoblog/static/efaf08808eb19eca3435cc95fcf710c0/677e6/networkKind.jpg 261w&quot;
        sizes=&quot;(max-width: 261px) 100vw, 261px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;br /&gt;
그밖에 종류는 LAN, WLAN, WAN, MAN, PAN, SAN, CAN, VPN 등 이 존재한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;네트워크 이해를 돕는 기본 용어&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/54369d4f982bbc374ee0e66675b44663/6af66/node.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 71.2%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACcklEQVR42n1TTW8SURTtD3PnShNX3evOjS5rYjT+AjGmLkx00dgYtVWiTbENtEA/hCkI1FootIUBBmYGmBm+OxSYj+N7r3RakPQkL3lz731n7jnvvhkQ2FMWxfl5D2d6l+3b7QZMy8RN9RQz0wos22LJv4cxxOMhtvf53Gi2mmxv2fbNhLTAtCwYponuWddJ6noHqayAo3wdqUx2Otnoe4xwMBxC1RRGls6kMDCoNBPJ0wruv/Dj3mM3trg0O0B/TBdFTamA44LOt0PY7jQRCKxBkooIBlbR6/VQLBaRFyQsrWzDG4hCUVWIkoT+YOAclmURBwexsS4ZYatdB8+nEU9m4Q1nEU6csguh8ig0TcWQqBgaBqq1CgpSA9GMht+HAkRRQCjsd2pnaLsezzIS+wk8nd/F3UcrePf5F2pVEVJFAXdUxyfvKdwbGaKkA0muYM4VwB1S9+ZDEGXhBHwheyWZ8vI8jxyfgy/AIRT5g3K5zJKerWPcfvgNtx4s4bnrJ/SzDjpdHf6dKPZiSchSGWvrPzC4ZgOTrBBzl78uklm7GIsC8a9/rqNQqsC9uoP1zQhKJYHlVFVhHtM77vd7xFsZxmg+HcJmq0VI8sR0AYkERw7VoTU7EInkqxHSmX9yTUW3N8T2jh+53MnYKDmS7ZGhqlpFMhnHy8UYZue8eLWwTS5EgShX0WhoePslgtknPjx7vYl8PkPktx3CsQ7N0csoi0XshoL4+J3D/MIGSpLG4oZ5kd8MH8P13ovI/jH29raQL+SmE14Gmq06kV0kLRMCy/jv3dK4bQ9ZXBQLZNwaF4SYIJwE5b9ck3HLHu9oEv8AuwoTy8i/eoYAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;노드 이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/54369d4f982bbc374ee0e66675b44663/0b533/node.png&quot;
        srcset=&quot;/neekoblog/static/54369d4f982bbc374ee0e66675b44663/fac75/node.png 125w,
/neekoblog/static/54369d4f982bbc374ee0e66675b44663/63868/node.png 250w,
/neekoblog/static/54369d4f982bbc374ee0e66675b44663/0b533/node.png 500w,
/neekoblog/static/54369d4f982bbc374ee0e66675b44663/6af66/node.png 640w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;노드&lt;/h5&gt;
&lt;p&gt;노드는 데이터를 수신, 전송, 저장할 수 있는 네트워크 내의 연결지점이다.&lt;br /&gt;
네트워크가 노드에 접근하려면 어디에 접근하는지 알 수 있는 IP주소같은 식별 정보가 필요하다.&lt;br /&gt;
노드는 따라서 IP주소같은 식별 정보를 가지고 있는 컴퓨터, 프린터, 모뎀, 브리지, 스위치 등 이라고 볼 수 있다.&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;IP주소&lt;/h5&gt;
&lt;p&gt;네트워크에 연결된 각 컴퓨터나 기기는 데이터를 주고 받기 위해 고유 번호를 부여받는다.&lt;br /&gt;
이 고유번호는 IP주소라고 하며, 네트워크에서 데이터를 전송할 때 주소와 같은 역할을 한다.&lt;br /&gt;
이 정보를 패킷의 해더에 포함시켜 전송하면 어느 컴퓨터(노드)로 가야하는지 알 수 있다.&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;IP(Internet Protocol)&lt;/h5&gt;
&lt;p&gt;인터넷이 연결된 네트워크에서 정보를 주고 받을 때에는 정해진 규칙이 있다.&lt;br /&gt;
이 규칙을 IP즉, 인터넷 프로토콜이라고 한다.&lt;br /&gt;
따라서 IP 주소는 &apos;인터넷이 통하는 네트워크 규칙에서 정한 주소&apos;이다.&lt;br /&gt;
IP에도 체계가 있으니 한번 참고해보는 것도 좋을 것 같다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 366px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/f2d67fa461316d8b6c707d207619e181/8b153/packet.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.6%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABdklEQVR42mVQbU+CUBTmX7e1PvSlrVZz9alWmx9sNWdvlqiJ8qYgaKCkAr7ALFeGEKRMlOZbF9hsq2d35+zec57zPPdAqz9YegBRNXVef+f0t64x8J794ng8Ho1GDsBkAtqg1T8EfYzSuhJKUZ4pyo1gJoifpvmhaZaP+XwO/VKWC5A0uarm4VcqVa6V8J6aVaRGr7smjx3Htu2RbU+nU3CFfKVlYBiEVoVlkzEufZOhsaRciwtlvtP0i4vA9nA4BM7BlDV5JbXTGL1HlkPP1GUTg5u520KFzvaUtCIKL+r6L7phAOemZU1d1yMHI59FEi1GcPaigMZ4LMWjiVyRyEg1uPpUaXvK88UCOAd78o7jzGYzj3x8sHF2tH0X38GZfYTeLSGndThaT0SyDHrfER9U+fw6HD7cOglt4ljKtL76/b5hGANd1zQNIog0lc+xHMKLCNfI1AVS5hiZo3lJYNQWq7YpjqbyCEk8tjoyEASr+vbhuu4P9Oumba0QsN8AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;패킷 이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/f2d67fa461316d8b6c707d207619e181/8b153/packet.png&quot;
        srcset=&quot;/neekoblog/static/f2d67fa461316d8b6c707d207619e181/fac75/packet.png 125w,
/neekoblog/static/f2d67fa461316d8b6c707d207619e181/63868/packet.png 250w,
/neekoblog/static/f2d67fa461316d8b6c707d207619e181/8b153/packet.png 366w&quot;
        sizes=&quot;(max-width: 366px) 100vw, 366px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;패킷(Packet)&lt;/h5&gt;
&lt;p&gt;패킷은 pack과 bucket의 합성어로 네트워크에서 정보를 주고 받을 때 사용하는 작은 데이터 조각을 의미한다.&lt;br /&gt;
예를 들어 IP 주소가 포함된 작은 데이터 단위는 패킷이다.&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;라우터&lt;/h5&gt;
&lt;p&gt;네트워크를 연결해주는 장치다. 라우터는 데이터를 패킷으로 나눠서 어디로 가야할지 정해주고 전송한다.&lt;br /&gt;
예를 들어 항공에서 관제탑 같은 역할을 한다고 볼 수 있다. 비행기는 패킷이다.&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;라우팅&lt;/h5&gt;
&lt;p&gt;라우터가 데이터를 어디로 가야할지 정해준다고 했는데 정하는 과정을 라우팅이라고 볼 수 있다.&lt;br /&gt;
라우터의 라우팅 방식에 의해 데이터가 어떻게 전송될지 정해지는 것이다.&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;스위치&lt;/h5&gt;
&lt;p&gt;스위치는 동일한 네트워크, 즉 단일 네트워크 내에서 장치(노드) 간의 연결을 관리하고 데이터 패킷이 올바른 목적지로 도달하도록 한다.&lt;br /&gt;
라우터와 비슷한 기능을 한다고 볼 수 있다.&lt;br /&gt;
라우터와 차이점은 라우터는 서로 다른 네트워크 간에 데이터를 전송하는 장치이고
스위치는 동일한 네트워크 내에서 데이터를 전송한다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 두 장치는 함께 작동될 수도 있는데, 사무실 내 프린터같은 장치들을 연결하고 그 장치 들은 스위치를 통해 라우터와 연결되며 라우터는 이 네트워크를 외부 네트워크와 연결한다.&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;포트&lt;/h5&gt;
&lt;p&gt;네트워크에서 특정 서버나 애플리케이션을 식별하고 통신하는 데 사용되는 논리적인 접접이다.&lt;br /&gt;
&apos;포트번호&apos; 라는 말이 자주 나오는데 이것은 접점의 장소 번호이다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 번호가 필요한 이유를 알아보자.&lt;br /&gt;
서버를 실행할 때, 종종 8080이나 3000같은 번호를 볼 수 있다.&lt;br /&gt;
서버가 인터넷에서 통신하기 위해서는 어디로 연결할지 알아야 하는데 이 때 포트번호가 필요하다.&lt;br /&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h5&gt;자료 출처&lt;/h5&gt;
&lt;p&gt;_출처: &lt;a href=&quot;https://velog.io/@rockwellvinca/Network-%ED%8C%A8%ED%82%B7%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%83%9D%EC%84%B1%EA%B3%BC%EC%A0%95_&quot;&gt;https://velog.io/@rockwellvinca/Network-%ED%8C%A8%ED%82%B7%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%83%9D%EC%84%B1%EA%B3%BC%EC%A0%95_&lt;/a&gt;&lt;br/&gt;
&lt;em&gt;출처: &lt;a href=&quot;https://steemit.com/network/@sapphire317/link-node-cloud&quot;&gt;https://steemit.com/network/@sapphire317/link-node-cloud&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[github-pages notfound error 이해하기]]></title><description><![CDATA[Github pages React-router 404 Issue 이번에는 CRA를 통해 만든 blog를 github pages에 배포했을 때
react-router에 인해 refresh 후 404 error…]]></description><link>https://yeaseul7.github.io/neekoblog/ghpages-error/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/ghpages-error/</guid><pubDate>Thu, 08 Aug 2024 12:40:56 GMT</pubDate><content:encoded>&lt;h2&gt;Github pages React-router 404 Issue&lt;/h2&gt;
&lt;p&gt;이번에는 CRA를 통해 만든 blog를 github pages에 배포했을 때
react-router에 인해 refresh 후 404 error가 반환되는 문제를 다룰 것이다.&lt;/p&gt;
&lt;h4&gt;문제 원인&lt;/h4&gt;
&lt;p&gt;github pages가 정적 사이트 호스팅 서비스 이기 때문&lt;/p&gt;
&lt;p&gt;react-router는 새로고침을 하면 클라이언트 측에서 라우팅을 처리한다.
새로 고침을 하거나 경로를 변경하면 페이지가 새로 로드되는 것이 아닌 js가 동적으로 콘텐츠를 변경시킨다.&lt;/p&gt;
&lt;p&gt;근데 Github pages는 라우팅을 모르기 때문에 경로가 변경되거나 할 때 경로에 해당하는 파일을 찾으려고 한다.&lt;/p&gt;
&lt;h4&gt;발생 현상&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAACvCAMAAABqzPMLAAAAmVBMVEXx8fH09PQAAADFxcXHx8f39/fDw8Pv7+/r6+vKysrU1NTo6Ojl5eXZ2dng4ODPz8+9vb2urq6jo6OWlpa3t7eyzOCJiYmpqan59vOUlJTi6O2/0+SryN////+fn5+0zeFcXFyBgYHY4upTU1PJ2eadwNs3Nzd1dXVmZmbP3eiOuNiCstUtLS0kJCR9fX1KSko9PT1sbGyItddkgxPnAAANkUlEQVR4nO2dCXvrphKGGbEvA8iWd9lp3Jy9+///cXeQJdtnb/v0xLkJbxZLgEbSZ0DDgBPGKpVKpVKpVCqVSuVZIc34CsZIuErWN7qgJ4Y8NF2RZT9/3TQ/Wzklq2Ypv3XcS0HapskkkFw2zZufmqY9qQKsaeZVIBIiNINAEJvXer9PzS/7IV3+WgUakD83b4tA8remtK79cqhOTN5TchWIhJg39+0g0O9NoH1IgyzUAf2BVSBWGtYf+9kgUPPT0Lag+UmW383eVoEY6KYxchTo55McRaD9L42QVSBqSW/pofW5QHJDT3ioAjG5at7ugX4reS3Q3jWv97LUoP2NL/DGUIf8K89Z3TebbEigqQ+idpeJQ/Mmx1tf402BrjkT92+aMrKghnUIl+QOvmvlGQO4agtvmmVryPFRxQ+iF31K3jR/tvFFC8RAFvZDH0Qe9S9xT/7P6z0bkiV5RPuXrc/I6SnG5Jumeft707hRlPoUm5hG83CgTuetm0QBUUfzIzAGgYaGBZ8lVyqVSqVSqVQqlUqlUqlUKpVKpVKpVJ42xgdtzHUK6JL6UaEXvBRYLlezkJYShllDRi/SKWD3WbJhQgzKF7Yvd3JMbhzGds4OBy1Xm/u4WrbtvU5v3PIeD7rDP+cbfb95wes75Ian2M3xfh7lyou02W+ckOyAWR5mLCPtCxdecg2i1hXbjS5rX2ZBpcNsjhut53o5F1SXSKBlWM5fsEAsUBfsA3gPbOitkbocSgUTJUOvA9CX99+382IAxuBqu1KpVCqVSqVSeX5A4VvZn+x/YWva+2rR717D9/PhVi45uK5DK09CAEQWB70ATt+S40nBUUdph01KjJYGqNNhZMaDFBKm49hQ9LJ32oxjYTiZoIQhvZiaSk1lT+VwOinkaNy33sgfqFCMcqZ04rTFU4orUzRB5Z3SmeOKS8d5gpQdchN4C+AEzoKeZSoNimsWhWWqNZbbNjrOLPece+b5SioLQ0IAy5NRmElelbRytNU5FJhCp8AUU5rT/XflHJF3CSxdReCpHU8qwyyZsn0LhWIEG11rMynhOUvZzgCUpG8upLBCKilE+Z7ZTK8AVtCN029Ko1siMUUrpEuRCpvWKiVkl8rhVkCxqxSXwKWg78QoudhzRliZRLYxiJMpZWeMSg3nKPt0FVGF65MaR9u3qEOIwKNzOkIgSViykmoQva+K3vqTQJAFo9vmVMVkB8BB0RUPooHGCGrfUQVANELopKMBetMdkHjoEROLXmYShVugegLJeMuE86IInwVGPpjiqYRIVDmHkl2RGNCXd2g6qSCBSPBbCOQ93YOJCZhWMbIM1D4YyRPK9USqX1GIYOm1vNmKxHM2pgjCUSYkajRRoUx0g6mUpRtT1AipAxFOJqT+pSRQz0ZH+EA1jw61IegYE4pYTswGU1SLqTKfzpGZotKBKYyk5HBSquc6lCu6gUAjcP4Z4+zTUwOSYJe0sQOfHm/nThrOZaZO+pIK5zNc718ennD1CCzZOB0H7OpUlzJPjds8PCqVSqVSqVQqt+cLsZy/ccS3Uq985H9v+Mq3hn9s6D+kDHEMc2NwhoWTnz9+nYYWEfz1+ICGY+OAYRx1DM62L6mUT0X9mA80GHOXiBB8PiCBi00PJ8MwmcPTNhlwjqvgbqVQVK20OSuDRjmgUSSNFBFQUwKgs6C5Q39gooyk0ToRKYHLaMQQNjJIBiLSKHSFrWXIw8H4maKhJw/gZ05yr5jjwShEgcobZWiwJcAp7biOooTLyCYN8LtEJYuJkmlkMQfFrhqG+zSyv5lAzgGGLLm1NLDXSXgDAjgfwkGqDL8Nl9aGXP7GBFPAMawsSRKyBuUZ10l5G60UkoRCx0usiIPgvjtFerJXSnKMLYdMeyaDscxgEnRw9mTakM0YVomk0DmQmFZ5XS4hOhtKwIME4hlvLBAvITGkSxzeQp1xSChvG1WTohRyVkJBJUQUrUiJIw3yPd0nSRpUCSpJEalSiDFWRBZOGx26EjoKxVzZs2CSDIJxn7BFB1afbNoSpSNRMjrvEulisWyTbOVKEpW6kUKBbi5Q43IucGpiiDwyyNqrEJSghu95crLTHCFRf0BfyLOTaEqMNNFdKnQykRiJDJAKLnvoqKRWZIa0d5Ea09CLDAeTWVaakBBouUGuqTGXQlRFUlSeTJCwZJbMYfSO0xukSv8zWGC3Cwd9HF5n3o6BmKkTHfLi1HFP8Z4pAn85cAq7j2EluOrtz9uXwD07PxAu+exjc+z8JPjm5Muj85SupfJU+Xqd/SjnMSrT3z3Ho/qL1FWSx3PpB05OnkbwseNJ49gDIAYfr4LO3zD46X701+mTnzi6hGdvtPRseB3F/rqfTg8IeLzpQ3ouSzBK03M3Wi1QumQOWtOeczK6NLiBEFHE4HTZL7ehgemx60VyKqe+fbj57hzvPyWgVFSIvKgYSW565JNbY8gBxZb8CrIqtIjki9KJbQq83D49+8l3kLlooOM4vhjOCvSsj2CK40mX/FgC0XOTXDhFI4JgmcVYZp4GgVplPQmkjIEya+idjS46qVKYJbHyGcl5If/EhcgDUlHMmQ7lUJ7hzOSQhMi2zIXRY91SRjLkBmSTkgsieSMkZBCOTloSRIwmZfIWfSQfgSRzlnXRkPuUMNBV8ORnNmXyt8YpRv1I04dUg2CYPiUXRiuZUmS2CFRqD0vkzEHx1waBOouCanf2yUrjZC7zUxgpr7VUHbDrlMoxCtnZMovOZBfnSmCAkxMsBXl5dKPkVTrynB35ncWrdIZOqjsagESWWkyAdFKqU0wK8pK4cSsV5lR3lOZ23ylO7tLoeNpHEogaDSu+GTUGw5STlstWU89EvjS51h2PiYZTSA3ORx8T6eg0Cqs7v0qypbrnST7RRYUrcuoyNyRVxpZh57suoVOnYVSgNmU4DTucieh5V/xO0rjMxLLiO8okrcJIQzTDVaRKCa4NVGFz7GyreWeoTBLonC02aCco7x9njn7qMNjFPTuvrTj3mNpdZghhXKSRTh/i0VNnUyhpZ+dv9CUjOb75euB+yUzy2o88u54XD/R8MnY5y5UH+oT4wuV86Qq/6jH8o+RKpVKpVCqVyu35jyKY3zDyb+2fgz5wsfL44Vbo+4f1NMzYavoZM7ZHBkdKYOvj9S1epvyKs388LzdM8FHOOBIocRCN50gTO8V9JiMAQcMn92/8lCuzpfFZiB6wDGbQDENGdY4VwePIBf36+M7s1uu77fqh37IP/cNx/XAE+HDU28Vuy9Z3/fphS4W2bLt92O7MesHo9cNxe6c/HEHv1ts7Bp1jVtJ412NIRlrmEZIpK2fRt9E7GWiwGxBi8isPwclYZgMcDYDjMPkDcWbK56TR6bI8GATJtHGzlPmqxf0qRsAukdq5E/OyZjZElE7L9AizrPD+3W67MLudef+wfbVd97t3/bvtjjYetv1deQXKuDs+HHe677evzOIOFv120euHY7/o173ZvWe9tJpr2xngMRsa6QseTqENHgRlBNfKNlruY3JW6BSw1RZIO+cwcu+45FRYBWcNYsuEgBbMgWrOhh+6+eoeZ/tNnm1QqvmhS+1vYdnNxWHulqsfP/+zfnVcrD/c7Xa7vl+THoudXvR3pNSCZCGBqIZRFdrtjus7drdY9+vF+7t+sSaZ+uNiSKA9EoiVCUaAYVJwmGvMNo+rzHUaJmdjFIGjS4IqELeszCcrZ3QSp5X8VNijUxGH1fwC9EHP2jmKnMwMV3LeRVtWnHuJsyW2+3nbtqzdmB9ehaA0oF2/vVv8ZfoPZv3+le5NT41mse0/7Eigd/1fVJXYoj/2f90VPY79AwnUP7xaLN6/Wu9on1Ito3srAg0Tq8oJCDxNy/Ct8ieByrTgquwbQQIlscLMWVJUy0TrIWeSA4tAKFqqUJul3/j7FuUqLufzvFlqyGWScrnBw+EQljksl/7HV6HzJ2roZz1FWk696voqhD5kX5Z60Dbl0gFXU4JT33xeDHJ97BQGugR3PokbsUu4RyZbVndIyehryC7/W0HK0aaU/n6+Kv9tQb7cf0LxvYmTJzW7WqlUKpVKpVKpVCqVSuV5oENZIqjLHz+GIfTuw7Rw50vRCjDBlGw95k7R+svLM8PwJCJfKZkDBGXLL6fmJvuD84GJ8ElxSDZZ70XAueIusKBS1MpvTNZzZ6JUN/l7Lj8SRG8xYadmSqqsM2gljPLYCpMSZhyqRBgoW9pa0SnFOi4wKcGUMspaOsB1IkZVPhfyzCiLXV1ypI7adxkyhACZ6karTFJhXICqB8qWT8qhVVSEY1QCOsWy8ZYn3/EYO/1YK1YfD3AZfejKJ+7Kn1yKwHhmOWRHOojyCZ9PiiubOkSbo00GWU5RYMjQBUXVkHOWn9+fCL5aTHlec3n1cZ1PMUJZjTnCpRj75gEvjulTT5VKpVKpVCqVSqVS+bEA83FY6Vv5IhBVwd36Op4q5S8WDPBbX8kTJeSoMVAby6m2si8AVp3+LrZWzy8k/19Aupw2IH0Wga0QOk8COYW3vZQnCs/h1PcI9ek0WYWVipNs1NRXp6mtVT5GK588Y0qpm/wTg/8DQqlBwMdp1srnaGeopYWqz1d5ngs3KpVKpVKpVCqVSqVSqVSeJv8DbBGneug+U1cAAAAASUVORK5CYII=&quot; alt=&quot;error 화면&quot;&gt;&lt;/p&gt;
&lt;p&gt;나도 마찬가지로 react-router를 사용중이었고
이 issue에 직면하게 되었다.&lt;/p&gt;
&lt;h3&gt;해결 방법&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://create-react-app.dev/docs/deployment/#notes-on-client-side-routing&quot;&gt;CRA Docs&lt;/a&gt;에 들어가면 이 문제에 대해 상세히 설명해주고 있다.&lt;/p&gt;
&lt;p&gt;react-router가 사용하는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;BrowserRouter /&gt;&lt;/code&gt;가 라우팅 과정에서 동적으로 페이지를 변환시켜주는 것이라고 볼 수 있는데 이게 정적 사이트 호스팅을 지원하는 gh pages에서는 동작할 수 없다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://create-react-app.dev/docs/deployment/#notes-on-client-side-routing&quot;&gt;CRA Docs&lt;/a&gt;에서 대체적으로 아래의 방법을 사용한다고 하니
나도 &lt;a href=&quot;https://github.com/rafgraph/spa-github-pages?tab=readme-ov-file&quot;&gt;spa github pages&lt;/a&gt;를 참고해서 문제 해결을 시도했다.&lt;/p&gt;
&lt;p&gt;이 방법은 404 에러가 나면 404.html 파일로 보내고 거기서 script로 경로를 찾을 수 있게 해주는 방법이었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;두번째 방법을 선택한 이유&lt;/strong&gt;
처음에는 404 error가 이 경우밖에 나는건 아닐 수 있는데 이렇게 해도 되나 고민했디.
하지만 redirect 시키며 경로를 찾게 해주는 방법이 대체적으로 많이 쓰이기도 하고
첫번째 방법은 코드를 싹 고쳐야 하는 번거로움이 있다고 생각해서 아래의 방법을 선택했다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rafgraph/spa-github-pages?tab=readme-ov-file#usage-instructions&quot;&gt;문서&lt;/a&gt;를 보면 실행 절차에 대해 더 자세히 얘기해준다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rafgraph/spa-github-pages/blob/gh-pages/404.html&quot;&gt;404.html&lt;/a&gt;을 그대로 복사해서 루트 디렉토리에 붙여넣는다.
여기서 만약에 custom domain을 사용하지 않고 있으면 404.html 파일에 pathSegmentsToKeep를 1로 바꿔주고
react-router를 사용하는 부분도 절대 경로를 repo 이름으로 변경해줘야 한다&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;BrowserRouter basename=&quot;/yeaseul7.github.io&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 localhost:3000에서 돌리던 로컬 서버는 기본 경로인 repo name이 추가되었기 때문에
테스트 하려면 localhost:3000/yeaseul7.github.io/로 접속해야한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[재귀함수 알고리즘]]></title><description><![CDATA[javascript로 재귀함수 구현하기 재귀함수란? 함수 안에 자기 자신을 다시 호출하는 함수 대표적 사용 예시
피보나치 수열 구현하기 프로그래머스를 통한 예시 보기 문제. 구슬을 나누는 경우의 수
난이도. Lv…]]></description><link>https://yeaseul7.github.io/neekoblog/recursion-algo/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/recursion-algo/</guid><pubDate>Thu, 08 Aug 2024 12:34:56 GMT</pubDate><content:encoded>&lt;h2&gt;javascript로 재귀함수 구현하기&lt;/h2&gt;
&lt;h3&gt;재귀함수란?&lt;/h3&gt;
&lt;p&gt;함수 안에 자기 자신을 다시 호출하는 함수&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;대표적 사용 예시&lt;/strong&gt;
피보나치 수열 구현하기&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;프로그래머스를 통한 예시 보기&lt;/h3&gt;
&lt;p&gt;문제. &lt;a href=&quot;https://school.programmers.co.kr/learn/courses/30/lessons/120840&quot;&gt;구슬을 나누는 경우의 수&lt;/a&gt;
난이도. Lv0&lt;/p&gt;
&lt;h4&gt;문제 설명&lt;/h4&gt;
&lt;p&gt;머쓱이는 구슬을 친구들에게 나누어주려고 합니다. 구슬은 모두 다르게 생겼습니다. 머쓱이가 갖고 있는 구슬의 개수 balls와 친구들에게 나누어 줄 구슬 개수 share이 매개변수로 주어질 때, balls개의 구슬 중 share개의 구슬을 고르는 가능한 모든 경우의 수를 return 하는 solution 함수를 완성해주세요.&lt;/p&gt;
&lt;h4&gt;제한사항&lt;/h4&gt;
&lt;p&gt;1 ≤ balls ≤ 30
1 ≤ share ≤ 30
구슬을 고르는 순서는 고려하지 않습니다.
share ≤ balls&lt;/p&gt;
&lt;h4&gt;Hint&lt;/h4&gt;
&lt;p&gt;서로 다른 n개 중 m개를 뽑는 경우의 수 공식은 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/54c8b2b9-f88c-4a09-8956-7560ff7ea918/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-08-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.37.53.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;나의 풀이&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;balls&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; share&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;recursion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;balls&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;recursion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;balls &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; share&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;recursion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;share&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;recursion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;recursion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 재귀함수가 &lt;code class=&quot;language-text&quot;&gt;recursion&lt;/code&gt; 함수 인데
&lt;code class=&quot;language-text&quot;&gt;recursion&lt;/code&gt; 안에서 &lt;code class=&quot;language-text&quot;&gt;recursion&lt;/code&gt; 자기 자신을 호출하고 있는 것을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;(n === 0 || n === 1) ? 1 &lt;/code&gt;이라는 종결점을 지어두고
이외에 자기 자신을 계속해서 호출하게 한다.
그러면 피보나치 수열 구현이 완료된다.&lt;/p&gt;
&lt;p&gt;재귀함수의 대표적인 예시가 피보나치 수열을 구현하는 것인데
해당 문제가 연습하기에 좋아 보여서 가지고 왔다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[About. Neeko]]></title><description><![CDATA[Hello, Welcome to Neeko 👋🏻 안녕하세요. 이예슬(Neeko…]]></description><link>https://yeaseul7.github.io/neekoblog/about/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/about/</guid><pubDate>Mon, 05 Aug 2024 03:22:22 GMT</pubDate><content:encoded>&lt;h3&gt;Hello, Welcome to Neeko 👋🏻&lt;/h3&gt;
&lt;p&gt;안녕하세요. &lt;strong&gt;이예슬(Neeko)&lt;/strong&gt; 입니다.&lt;/p&gt;
&lt;p&gt;해당 블로그는 공부하는 과정에서 배운 내용을 정리하고, 프로젝트를 진행하면서 느낀 점을 기록하는 데에 목적을 두고 있습니다.&lt;/p&gt;
&lt;p&gt;도움이 되셨다면 좋겠습니다. 감사합니다.🙇🏻‍♀️ 오류나 문의사항은 이메일로 보내주세요.&lt;/p&gt;
&lt;h3&gt;Yeaseul Contact.📬&lt;/h3&gt;
&lt;p&gt;📨Email. &lt;strong&gt;&lt;a href=&quot;mailto:cutie32769@gmail.com&quot;&gt;cutie32769@gmail.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;👩🏻‍💻GitHub. &lt;a href=&quot;https://github.com/yeaseul7&quot;&gt;https://github.com/yeaseul7&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;https://ghchart.rshah.org/yeaseul7&quot; class=&quot;grassGit&quot; alt=&quot;GitHub 잔디&quot; width=&quot;800&quot; height=&quot;100&quot;&gt;
&lt;p&gt;2024.03~&lt;/p&gt;
&lt;h4&gt;퀄리소프트&lt;/h4&gt;
&lt;p&gt;Work.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;javascript 기반 CRM 개발&lt;/li&gt;
&lt;li&gt;Azure 이용한 node.js 서버 구축&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;javascript, node.js, azure&lt;/p&gt;
&lt;p&gt;2023.12~2024.03&lt;/p&gt;
&lt;h4&gt;투인피니티(인턴)🐣&lt;/h4&gt;
&lt;p&gt;Work.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제은행 project 참여📚&lt;/li&gt;
&lt;li&gt;문제은행 : 데이터 기반 문제집 사진 촬영하면 비슷한 문제 제작해주는 서비스&lt;/li&gt;
&lt;li&gt;촬영한 사진 및 문제 데이터 저장 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;java, flutter, firebase, postgresql&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;folaio project 참여📷&lt;/li&gt;
&lt;li&gt;folaio : SNS기반 사진촬영 대회 플랫폼&lt;/li&gt;
&lt;li&gt;기본 디자인 및 사진 및 동영상 촬영 기능 구현&lt;/li&gt;
&lt;li&gt;데이터 저장 로직 구현 및 설계&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;java, flutter, firebase&lt;/p&gt;
&lt;p&gt;해당 블로그는 &lt;strong&gt;React, TypeScript, TailwindCSS, Node.js&lt;/strong&gt;를 사용하여 제작하였습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[교내 소프 경진대회 'domidomi'프로젝트 회고]]></title><description><![CDATA[2023년 소프트웨어 경진대회 대상을 수상[회고록] 이미지 프로젝트 이름 domidomi 💼 교내 행복 기숙사에 업무 효율을 높이기 위한 B2B 프로젝트 많은 근로생들이 근무하는 환경에서 업무 시스템이 매우 비효율 적이었고 NAS…]]></description><link>https://yeaseul7.github.io/neekoblog/shku-contest-retro/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/shku-contest-retro/</guid><pubDate>Wed, 20 Dec 2023 12:34:56 GMT</pubDate><content:encoded>&lt;h2&gt;2023년 소프트웨어 경진대회 대상을 수상[회고록]&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://yeaseul7.github.io/neekoBlog/images/softwareAward1.png&quot; alt=&quot;이미지&quot;&gt;&lt;/p&gt;
&lt;h3&gt;프로젝트 이름&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;domidomi&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;💼 교내 행복 기숙사에 업무 효율을 높이기 위한 B2B 프로젝트&lt;/p&gt;
&lt;p&gt;많은 근로생들이 근무하는 환경에서 업무 시스템이 매우 비효율 적이었고 NAS를 이용한 운영은 파일 업로드와 운영관리를 복잡하게 하였다.&lt;br&gt;
따라서 근로생부터 교직원분들까지 모두가 쉽게 이용 가능한 프로젝트를 개발하였다.&lt;/p&gt;
&lt;h3&gt;프로젝트 기술&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Next.js&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;React.js&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Typescript&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Styled-compoenent&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Emotion&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Vercel&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;Postman&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Spring&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Notion&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Mysql&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;기획 및 설계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://yeaseul7.github.io/neekoBlog/images/softwareAward2.png&quot; alt=&quot;이미지&quot;&gt;&lt;/p&gt;
&lt;p&gt;기숙에서 근로를 하던 팀장의 제안에 프로젝트가 이루어졌다.&lt;br&gt;
행복 기숙사의 요청을 적극 반영하고 이용자의 연령대를 고려하여&lt;br&gt;
UI/UX 에서 중요한 부분을 브리핑 해주었다.&lt;/p&gt;
&lt;p&gt;그 요청에 따라서 기술을 React, Styled-compoenet, Next.js 등을 골랐는데&lt;br&gt;
당시에는 파일 기반 라우팅으로 인해 디렉토리 구조가 이해하기 쉬웠고&lt;br&gt;
Ts 적용으로 코드를 보다 이해하기 쉬워 협업에 용이했다.&lt;/p&gt;
&lt;p&gt;😇 &lt;strong&gt;아쉬운 점&lt;/strong&gt;&lt;br&gt;
SEO가 필요하지 않은데 당시 Next.js를 도입한 명확한 이유가 없었다는 점에서 아쉬움이 있다.&lt;br&gt;
위와 같이 필요한 기술이 있으면 그 기술을 채택한 이유나 근거가 명확해야 하는데 그 부분이 부족했다.&lt;br&gt;
다음에는 명확한 근거를 갖고 기술을 채택할 뿐더러 문서화를 해야겠다고 생각했다.&lt;/p&gt;
&lt;h3&gt;프로젝트 진행&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://yeaseul7.github.io/neekoBlog/images/softwareAward3.png&quot; alt=&quot;이미지&quot;&gt;
피그마와 노션을 이용해서 회의록을 작성하고 피그마로 소통하는 등&lt;br&gt;
문서화가 잘 되었던 프로젝트였다고 생각한다.&lt;/p&gt;
&lt;p&gt;오류가 있는 부분을 팀 주간 회의에서 브리핑 하고 행복 기숙사의 요청 사항도 기록하여 까먹지 않고 확인할 수 있었다.&lt;br&gt;
보통 프로젝트 하고 나서 회고를 작성할 때에도 잘 기억나지 않은 부분이 있는데 노션에 기록이 되어있어서 원활하게 리마인드 할 수 있었다고 생각한다.&lt;/p&gt;
&lt;p&gt;😇 &lt;strong&gt;아쉬운 점&lt;/strong&gt;
개인적으로 취준 기간에 프로젝트에 참여하다보니 시간이 많이 부족했다.&lt;br&gt;
더 잘 할 수 있었는데 아쉬움이 많이 남았다. 그리고 코드 리뷰나 기술에 대한 분석이 부족했다고 생각한다.&lt;br&gt;
좀 더 깃헙 Issue나 PR을 활용했으면 좋았을 것 같다고 생각했다.&lt;/p&gt;
&lt;p&gt;웹 사이트 성능을 확인하지 못하고 사용자 경험 개선을 스스로 충분히 고려하지 못했다.&lt;br&gt;
단순 기능 개발에 초점을 맞췄다는게 아쉬웠고 앞으로는 사용자 경험 개선을 고려해서 최적화와 같은 분석 및 적용을 해야겠다고 생각했다.&lt;/p&gt;
&lt;h3&gt;프로젝트 결과&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://yeaseul7.github.io/neekoBlog/images/softwareAward1.png&quot; alt=&quot;이미지&quot;&gt;
결과적으로 학교에 도움이 되는 사이트를 만들었고 운영도 되고 있었던 프로젝트였기에 대상을 수상할 수 있었다고 생각한다.&lt;br&gt;
기능 개발 보다는 성능을 생각할 수 있게 만들어준 프로젝트였다. 당시에는 생각하지 못했지만 프로젝트를 회고하면서 부족한 부분이 많이 보였고 그만큼 배웠다는 것에 고마운 프로젝트이다.&lt;/p&gt;
&lt;p&gt;기술&lt;/p&gt;</content:encoded></item><item><title><![CDATA[개발자 면접 회고]]></title><description><![CDATA[…]]></description><link>https://yeaseul7.github.io/neekoblog/interview1/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/interview1/</guid><pubDate>Fri, 10 Nov 2023 12:40:56 GMT</pubDate><content:encoded>&lt;h3&gt;중소기업 면접 회고&lt;/h3&gt;
&lt;p&gt;취업 준비를 하면서 여기저기 많이 면접을 보러 다녔던 것 같다. &lt;br /&gt;
나같은 경우는 한번에 대답을 잘 못해서 준비 없이 갔다가 대차게 망하고 속상하기도 했다.
기술면접을 볼 때 더 잘볼껄 후회하는 경우가 많아서 최대한 회고록을 작성해보려고 한다.&lt;/p&gt;
&lt;p&gt;기본지식이 많이 부족한 상태에서 면접을 보다보니 절었던 경우가 굉장히 많았다.
하지만 면접을 보면서 부족한 부분을 채워나가는 것도 좋은 방법인 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;면접 종류&lt;/h4&gt;
&lt;p&gt;1️⃣ 기본 질문
2️⃣ 기술 질문
3️⃣ 인성 질문&lt;/p&gt;
&lt;p&gt;대부분 3종류인 것 같다.
조금 큰 회사는 2번 먼저 보고 1번과 3번을 나중에 2차로 보는 경우도 있는데
중소기업은 대부분 한번에 물어보는 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;기본 질문&lt;/h4&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;프론트앤드 지원 동기&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;사용자로 하여금 더 나은 서비스 경험을 제공하는 것이 흥미롭게 느껴졌기 때문입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;기술 질문&lt;/h4&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;component가 무엇인가요?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;rest.api가 무엇인가요?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;병렬 프로그래밍이 무엇인가요?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;HTTP 메소드에 대해 설명해주세요&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;통신 상태 코드에 대해 설명해주세요&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;MYSQL이 RDB인가요?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;인성 질문&lt;/h4&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;인생에서 가장 큰 일탈이 있나요? 있다면 무엇인가요?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;저는 독립한 것 입니다. 대학교도 졸업하기 전에 취업 준비를 시작하였고 독립도 하였습니다.
일탈로 독립을 하게 되었지만 그 결정을 결코 후회하지 않습니다.
덕분에 스스로 책임지는 방법을 더 빨리 알게되었고 저 자신을 잘 되돌아볼 수 있는 것 같습니다.&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;가장 잘했다고 생각한 결정&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;졸업하기 전에 취업하겠다고 결심하고 이행한 결정입니다. 대학교 졸업하고 취업하는 사람도 많고 졸업하기 전에 취업하면 취업계 등 번거로운 일이 많아지지만 빨리 취업함으로써 더 풍부한 지식을 보다 빨리 얻을 수 있고 경험도 비교적 빨리 얻을 수 있다고 생각합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[github 프로필 방문자 수 추가]]></title><description><![CDATA[github 프로필 방문자 수 추가하기 깃허브 프로필은 내 github repository에 있는 readme.md 파일을 수정하면 된다. 방문자 수를 표기하는 방법 사이트 : https://hits.seeyoufarm.com…]]></description><link>https://yeaseul7.github.io/neekoblog/github-profile-visitant/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/github-profile-visitant/</guid><pubDate>Tue, 10 Oct 2023 12:40:56 GMT</pubDate><content:encoded>&lt;h3&gt;github 프로필 방문자 수 추가하기&lt;/h3&gt;
&lt;p&gt;깃허브 프로필은 내 github repository에 있는 readme.md 파일을 수정하면 된다.&lt;/p&gt;
&lt;h4&gt;방문자 수를 표기하는 방법&lt;/h4&gt;
&lt;p&gt;사이트 : &lt;a href=&quot;https://hits.seeyoufarm.com/&quot;&gt;https://hits.seeyoufarm.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위 사이트에 들어가서 자신의 repository 경로를 입력해준다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/21b4d/profileVisitor.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.8%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACiklEQVR42nWQiU5TURRF+wMORJQpINBowFaQUUSIRjBMUhEUCgKxUCkq0EJVkJYWZChEiIoxSowQE3/JCZUgQzBEDZUO8Dos7yugcdrJyn4vuWfffa5iT2QiYVFKQQKJyZmosrNQpqsIjzlMjDKVqAQ10YlHOXBQRZTwiHg14bFHiFamsD82md0RSnZFiIzoRPaKDEWBposzGjMVdT1odVZqm23UX7VTrrVwKMdIZMp14jLbiEm7QViSgX2qa8TlmDic10p8RgvhqlYScjtILWgno6gdRWVDP+e0do4XW7jQOIihcxyDaZzLV0fR1I9SWD1GVskQh/KslNY/JKt0hMj0LhHQSU5JLykFFhHewz61mYhjZhQ1TQNomwc5U2Enu9jKpSvDNLWN0WgYwWx5gs3xErPtBWX1E+i7nnO6apRwtZGTZVaKqvspqB4gt6yP5Pwe4rNuotDq+mgw9NPSMUK1bpCGVge1egdFF22U19rFZUNUieYlYjD9bC9J+bfJEF7ZMExJzV3yNX2cEqQV3kF5QjS8ZZvipu0pIxMzDN2bwe6Yxmydotk4id70mE7LM/odM3QPTKMzPqXu2iMqm+5T0zJJW/cU7QK96QnndQ+o1E+i8PkD+GUCWx6QPRBEknysu9w4v7v4vu5m3e0JudvjxefzI/kCIQ9uz0mSP+QK/lAwGAy5Rwy+fveBV4K37+eY/TjPm9k5FpZXRJCP/0khz29n/JTXs4HTJW2FC4Lb/LpU3uT3oUDoDH833Gn3aX6JlaVllhcWWF5cDH271taQvGJlgV+09Hg8OJ1OvOJflrS5+e9A76afNdcGG+KAJN5JbiO/rcyO5LVXV1dDfPv2Fbd3k89fnPwA3WR3FjsPp1MAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;seeyoufarm사이트이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/0b533/profileVisitor.png&quot;
        srcset=&quot;/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/fac75/profileVisitor.png 125w,
/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/63868/profileVisitor.png 250w,
/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/0b533/profileVisitor.png 500w,
/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/1d69c/profileVisitor.png 750w,
/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/00d43/profileVisitor.png 1000w,
/neekoblog/static/47e47f48dca4fa5fb6a0be1be78de167/21b4d/profileVisitor.png 1280w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;https://github.com/yeaseul7&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;입력하고 나면 아래와 같이 나타난다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/neekoblog/static/812ed01061400c311201b259d643c717/21b4d/visitorMd.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 84.8%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC1klEQVR42qVU204TURSdf/DBZ8SEKDGWS4Em+AN+A6DCA1BA+BL/wVc+Ah4kMaZvFoPW3mampS3Tud/OXJf7nClNicbEOMnK3uecPXvtWXufkdIMsMIcNgNYgv9+pDjN0dUYVJ3hzgoRxxFYFCMMGRiLEJFf2EjYPM8LZA+RUWV8X0qzDMPRCIqqoiPLUPu3hAEarTa6ag9dpQe5dyv25V4fASWN0xQ5VTOLbEIkxZ4LZzSAZ1twTFPANgyYY11YS9dhTXx+xtfcphF7CBYiJyLJv9MwkgewzACp7yHzfQHuF5j1J/A8JK47Aw+xZSEiIsnWDDT6NpoDDxYdun4Ay3Hhh+E/NYNXF1FSKaZPzdNYbGakpwAXmIQmYfD5yxUum+f4JJ+jodeKl0krcBSLwiRJkdAba7DJMW0HIWO/MafEnOUpnZvoD4foD0ZiCuI4Fp1/UKHNE2oaVOqkQp11uRYUeF/pdEToBdNyRPeHpHlEMQmviGwRQ8T3FfrUtXZbRo+YDdOCrhvTZNymSSpeNijhYKTBDwJaU9VZPpGJ4vIMCVUbWWaRUKEKO4RmRyHWFNfX17i4uJzqyh/DstHqqDSXffxsd5GQOjfmFb6OLwppkrj4ZEatjmiGEtKAkYZcM9dxYBDRbKNifmPE7WHiFmVJDi+i2WS6mOyE9nkukdCkW2AOhohdBwgDutRET/og9Iv1PYh46gc+8oARIhGfB1QUFSI1Gg1s7bzB23e72N8/wPHJCapHRzg4PBRWoFrFEdlDbo+P8f70FKeEs7MzYat7W9jf24amjSHVajUsLj7Hq81NlFdXUS6Xsby8jFKphLW1NeEvLS1hZWUFq3S+sLCAJ3NzmJ+fF3hKeFzZwaMXr/Hz+zdI9XpdJNnY2BBYX18XtlKp/BE8lpNxEo5S6SWe7X5EafsDWj8oIR8Jlf40Mv1pOBRFEfjbmsfPotesQ23diIvxC7G3rx/Exhv9AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;seeyoufarm사이트이미지&quot;
        title=&quot;&quot;
        src=&quot;/neekoblog/static/812ed01061400c311201b259d643c717/0b533/visitorMd.png&quot;
        srcset=&quot;/neekoblog/static/812ed01061400c311201b259d643c717/fac75/visitorMd.png 125w,
/neekoblog/static/812ed01061400c311201b259d643c717/63868/visitorMd.png 250w,
/neekoblog/static/812ed01061400c311201b259d643c717/0b533/visitorMd.png 500w,
/neekoblog/static/812ed01061400c311201b259d643c717/1d69c/visitorMd.png 750w,
/neekoblog/static/812ed01061400c311201b259d643c717/00d43/visitorMd.png 1000w,
/neekoblog/static/812ed01061400c311201b259d643c717/21b4d/visitorMd.png 1280w&quot;
        sizes=&quot;(max-width: 500px) 100vw, 500px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;markdown 코드를 복사해서 readme파일에 붙여넣으면 끝!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GDSC 회고록]]></title><description><![CDATA[GDSC란 무엇인가요? 학생들이 개발/리더십 능력을 키울 수 있도록 지원하는 프로그램입니다.
GDSC성공회대 공식 사이트에서 더 자세한 내용을 참고할 수 있습니다. GDSC에서 무엇을 했나요? Web Study
매주 React, Next.js…]]></description><link>https://yeaseul7.github.io/neekoblog/gdsc-retro/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/gdsc-retro/</guid><pubDate>Sun, 08 Oct 2023 12:34:56 GMT</pubDate><content:encoded>&lt;h3&gt;GDSC란 무엇인가요?&lt;/h3&gt;
&lt;p&gt;학생들이 개발/리더십 능력을 키울 수 있도록 지원하는 프로그램입니다.
&lt;a href=&quot;https://gdsc.community.dev/sungkonghoe-university/&quot;&gt;GDSC성공회대 공식 사이트&lt;/a&gt;에서 더 자세한 내용을 참고할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;GDSC에서 무엇을 했나요?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Web Study&lt;/strong&gt;
매주 React, Next.js, Typescript등 프로젝트에 필요한 기술들을 학습하였습니다.
여기서 처음으로 React를 사용해보았으며 실무를 통해서 프로젝트를 마칠 수 있는 정도로 빠르게 성장할 수 있었습니다.
이 과정에서 React, Vue, Angular등 다양한 프레임워크가 존재한다는 것을 깨달았으며
Next.js를 사용해봄으로써 SSR에 대해 더 잘 이해할 수 있었습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;정규 세션&lt;/strong&gt;
Web, Backend, Mobile 파트가 모여서 프로젝트를 구상하고 참여함으로써 각 파트와 소통할 수 있었습니다.
소통 과정에서 Backend와 api로 소통하는 방법 혹은 프로토콜의 이해를 도울 수 있었습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;해커톤&lt;/strong&gt;
전세계 GDSC 소속 학생들을 대상으로 열린 대규모 챌린지 입니다.
Mintalk라는 프로젝트에 참여하였으며 해당 프로젝트는 의사들과 환자들을 연결해주는 서비스입니다.
정신과를 주 타겟으로 삼았으며 mock data를 기반으로 프로젝트를 출시하였습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;성장 Point&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;팀원들과 소통하면서 개발에 대해 지식이 부족하였기에 이해를 못하는 등의 어려움이 있었습니다.
이를 해결하기 위해서 팀원들과 소규모 스터디를 운영하고 지식을 공유하는 시간을 가졌고 일주일에 1개의 post를 올리는 챌린지에 참여하게 되었습니다.
또한 다른 사람들에게 스스로의 주장을 더 어필하기 위해서 탄탄한 배경이 있어야함을 느꼈습니다.
개발에 있어서 웹에 대한 기본 지식이 매우 부족하다고 생각했습니다. 스터디와 더불어서 개인 학습시간을 늘려 GDSC에 처음 참여할떄와 비교해 많은 지식을 얻어갔음을 느꼈습니다.
어느 솔루션을 해결할 때 공식문서를 최대한 이해해야함을 느꼈습니다.
처음에는 무작정 구글링을 통해 기능 구현에만 집중했습니다. 코드 복붙보다 동작원리를 최대한 이해한 후 기능을 구현하는 것이 스스로의 성장 속도를 증진시킴을 이해했습니다.
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;사람들과 협업하면서 &lt;strong&gt;같이 고민&lt;/strong&gt;하는 방법을 배웠습니다.
혼자 문제를 해결하려 노력하기보다 팀원들과 소통을 통해 어려움을 해결하고 잊지 않으려 노력하는 것이 효율이 더 좋을 수 있다는 것을 꺠달았습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;작성 일자 : 2024.06.25&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Fe 면접 회고]]></title><description><![CDATA[Fe 면접 회고 처음으로 면접을 보게 되었을 때 정말 꿈만 같았다.
'나도 서류를 보고 면접을 보긴하는구나' 생각했다.
그래서 javascript와 웹에 대해서 더 공부하고 갔던 기억이 있다. 면접 종류 1️⃣ 프로젝트 질문
2️⃣ 기술 질문…]]></description><link>https://yeaseul7.github.io/neekoblog/interview2/</link><guid isPermaLink="false">https://yeaseul7.github.io/neekoblog/interview2/</guid><pubDate>Fri, 30 Jun 2023 12:40:56 GMT</pubDate><content:encoded>&lt;h3&gt;Fe 면접 회고&lt;/h3&gt;
&lt;p&gt;처음으로 면접을 보게 되었을 때 정말 꿈만 같았다.
&apos;나도 서류를 보고 면접을 보긴하는구나&apos; 생각했다.
그래서 javascript와 웹에 대해서 더 공부하고 갔던 기억이 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;면접 종류&lt;/h4&gt;
&lt;p&gt;1️⃣ 프로젝트 질문
2️⃣ 기술 질문
3️⃣ 인성 질문&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;프로젝트 질문&lt;/h4&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;팀에서 맡은 역할&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
📍 &lt;strong&gt;&lt;em&gt;협업과정에서 어려웠던 점&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
📍 &lt;strong&gt;&lt;em&gt;기술을 채택하는 과정과 이유&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
📍 &lt;strong&gt;&lt;em&gt;API 연동시 문서 사용 여부&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
📍 &lt;strong&gt;&lt;em&gt;Notion 사용 여부&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;기술 질문&lt;/h4&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;React : useCallback useMemo에 대해서&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;React : Virtual DOM에 대해서&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;React : map 사용할 때 key 오류가 생기는 이유&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;자료구조 : Linked List와 Array&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;네트워크 : TCP에 대해&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;📍 &lt;strong&gt;&lt;em&gt;GitFlow에 대해&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</content:encoded></item></channel></rss>