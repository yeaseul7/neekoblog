{"componentChunkName":"component---src-templates-blog-post-js","path":"/ssr-server/","result":{"data":{"site":{"siteMetadata":{"title":"neekoblog"}},"markdownRemark":{"id":"3342f8e8-116d-5e3f-87a8-e8b2a0410bd3","excerpt":"SSR application 형성 과정 SSR 애플리케이션은 화면을 그릴 때 서버에 HTTP 요청으로 데이터를 받아와서 HTML 파일을 클라이언트로 전송한다. SSR서버와 클라이언트가 어느단계로 작동하는가? 브라우저가 특정 URL에 대해 HTML 파일을 SSR 서버로 요청한다. SSR…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/bc514/ssr.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRqIAAABXRUJQVlA4IJYAAAAwBACdASoUAA4APtFUo0uoJKMhsAgBABoJQBOmUGRZlPAce2D6MF9TQcAA/vYeGWc4U5rLgSqyzojYAvHxTrSkQ9V1bumaP2TUXBUSS4h40pas9VwypPKOCSysqQ6IpSG4LEwhQe5272g2e+8SF/v7B/7G2ISkv2K35nQtZp0pXBwkVrJhscHhT5zw6jPWibkCM0Q/gAA='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Network이미지\"\n        title=\"\"\n        src=\"/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/b0a15/ssr.webp\"\n        srcset=\"/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/42aaf/ssr.webp 125w,\n/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/1e0be/ssr.webp 250w,\n/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/b0a15/ssr.webp 500w,\n/neekoblog/static/c423bfd85ac19622b8c236d8e2418d12/bc514/ssr.webp 720w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>SSR application 형성 과정</h3>\n<p>SSR 애플리케이션은 화면을 그릴 때 서버에 HTTP 요청으로 데이터를 받아와서 HTML 파일을 클라이언트로 전송한다.</p>\n<p>SSR서버와 클라이언트가 어느단계로 작동하는가?</p>\n<ol>\n<li>브라우저가 특정 URL에 대해 HTML 파일을 SSR 서버로 요청한다.</li>\n<li>SSR 서버가 모든 요청받은 데이터를 가지고 HTML 파일을 반환한다.</li>\n<li>클라이언트에서 유저가 볼 수 있는 페이지를 랜딩한다. [초기 로딩 상태로 표시]</li>\n<li>클라이언트에서 VDOM을 붙이거나 이벤트들을 붙인다.(Hydration 과정)</li>\n<li>사용할 수 있는 화면이 완성된다.</li>\n</ol>\n<h3>내가 프로젝트에서 Next.js를 사용하는 이유</h3>\n<p>나는 프로젝트를 할 때 보통 react를 사용한다.<br>\nreact가 생태계가 넓어서 학습하기에 좋다고 생각하기 때문이다.</p>\n<p>'에브리 멍멍'이라는 프로젝트를 진행 할 때 Next.js도 사용하게 되었다.<br>\nNext.js는 SSR과 SSG를 지원함으로 서버에서 랜더링 된 HTML이 검색 엔진 크롤러가 콘텐츠를 쉽게 읽을 수 있다.<br>\n또한 Next.js의 app router로 인해 페이지를 구성하는게 유리했다.<br>\n작업의 편리성과 SEO를 고려해 Next.js를 선택하게 되었다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/neekoblog/static/fba964d42a47fe373f6cea775862a749/bc514/csr.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRpgAAABXRUJQVlA4IIwAAAAwBACdASoUAA8APtFUo0uoJKMhsAgBABoJQBAAlf8WvC325j0sMsJ14AAA/vYJraw0gBdyEbMfO9LoMfGGbIgwGO3Rhz6O/+PqVDY4iE0EmIytWa51ECtI5k6KICYfzXfIYs9cqs5AzmtnG5PZjZ6cWIZTlTbQNbvqbLwqIGmUTJmBdEdppb5WO8AAAA=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Network이미지\"\n        title=\"\"\n        src=\"/neekoblog/static/fba964d42a47fe373f6cea775862a749/b0a15/csr.webp\"\n        srcset=\"/neekoblog/static/fba964d42a47fe373f6cea775862a749/42aaf/csr.webp 125w,\n/neekoblog/static/fba964d42a47fe373f6cea775862a749/1e0be/csr.webp 250w,\n/neekoblog/static/fba964d42a47fe373f6cea775862a749/b0a15/csr.webp 500w,\n/neekoblog/static/fba964d42a47fe373f6cea775862a749/bc514/csr.webp 720w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>그렇다면 SSR과 CSR의 차이점은 무엇일까?</h4>\n<p>최초의 DOM tree가 어디서 생성되느냐에 따라 구분지었다고 볼 수 있다.</p>\n<p>CSR은 서버가 html파일을 가지고 오는것이 아니고 javascript 파일을 가지고 와서 화면을 그리는 방식인데<br>\n클라이언트가 빈 HTML에 서버에서 받아온 js파일을 이용해서 DOM tree를 형성하는 것이라고 볼 수 있다.<br>\n(그러면 초기 랜더링 속도가 아무래도 오래걸릴 것이다.)</p>\n<p>결론은 CSR은 클라이언트(브라우저)에서 DOM이 형성된다.</p>\n<p>반면 SSR은 서버에서 html 파일을 가지고 온다.<br>\n서버에서 html을 가지고 오기 때문에 서버에서 DOM이 형성된다고 볼 수 있다.</p>\n<h3>SEO와 SSR그리고 CSR</h3>\n<p>위에서 SEO를 고려해서 Next.js를 선택했다고 했는데,<br>\nSEO를 위해서는 구글 봇이 나의 웹페이지를 잘 읽어야 한다.<br>\nCSR로 되어있으면 랜더링 하는 과정과 그걸 해석하는 시간이 필요하다.<br>\n그래서 더 복잡하고 시간이 걸릴 수 있다.<br>\n게다가 javascript를 해석하는데에 제한이 있어서 그 점을 고려해야한다.</p>\n<p>반면 SSR은 html이 미리 랜더링 되어있기 떄문에 크롤러가 해석하는데 시간도 단축되고 더 심플하다.</p>\n<p><em>모든 경우에 SSR이 유리한 것은 아니다.</em><br>\nGoogle Bot의 크롤링 방식을 보다 잘 이해하고 어떤 것이 제한적이며 랜더링 최적화 과정을 거친다면 못지 않은 SEO를 구축할 수 있다.</p>\n<p><strong>SSR에서는 치명적인 단점이 존재한다.</strong><br>\n서버에서 html이 완성되어 전달되기 때문에 동적인 컨텐츠를 표시하기 힘들다.<br>\n때문에 클라이언트측에서 실행되는 js 파일을 추가해서 동적인 컨텐츠를 다룰 수 있다.</p>\n<p>Next.js에서 SSR와 CSR 개념을 결합해서 사용하는 Server-component, Client-compoenent 개념과 밀접한 관련이 있다.</p>\n<h3>SSR Hydration</h3>\n<p>서버에서 html 파일을 완성된 형태로 가지고 오니까 초기 랜더링 속도가 SSR이 <strong>무조건</strong> 압도적으로 빠른건가?<br>\n<strong>아니다</strong><br>\nSSR에서 완성된 Dom tree를 가지고 온다고 해도 동적인 콘텐츠를 가지기 위해서는 Hydration이라는 작업이 필요하다.<br>\n결국 이 모든 과정이 끝나야 페이지를 사용할 수 있다.</p>\n<p>제대로 비교하기 위해서는 초기 HTML에 내용이 어느정도 포함되어 있는지와 Hydration 과정이 얼마나 복잡한지 고려해야한다.</p>\n<p>사진 출처 : <a href=\"https://medium.com/@derekvogt3/csr-ssr-vs-ssg-87b112370db\">https://medium.com/@derekvogt3/csr-ssr-vs-ssg-87b112370db</a></p>","frontmatter":{"title":"SSR과 CSR의 차이","date":"August 28, 2024","description":"SSR vs CSR"}},"previous":{"fields":{"slug":"/memoization/"},"frontmatter":{"title":"React Memoization"}},"next":{"fields":{"slug":"/dom-vdom/"},"frontmatter":{"title":"DOM과 VDOM"}}},"pageContext":{"id":"3342f8e8-116d-5e3f-87a8-e8b2a0410bd3","previousPostId":"f3669100-bde6-5f96-9160-39899746559b","nextPostId":"e4160bb3-aaaf-55c7-8dc3-2ff55b91ea68"}},"staticQueryHashes":["1469588348","2841359383"],"slicesMap":{}}