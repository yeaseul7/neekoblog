{"componentChunkName":"component---src-templates-blog-post-js","path":"/dom-vdom/","result":{"data":{"site":{"siteMetadata":{"title":"neekoblog"}},"markdownRemark":{"id":"e4160bb3-aaaf-55c7-8dc3-2ff55b91ea68","excerpt":"DOM이란? Document Object Model HTML, XML 문서의 프로그래밍 interface다. DOM의 element는 object로 구성되어있다. interface란?\n사용자가 상호작용 할 수 있게 하는 프로그래밍 인터페이스이다. 즉, DOM…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/612f7/domtree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLUlEQVR42pVRy27TQBT1Z7Hgz9jCHlAXUBALqBASVcWii/CQSNNSEkKAOE8ndjzjx/gRj19xPLETj5nYJC2pUsGRdXXm3nN95t7hLMuazWbBBmEYxnE8L7BDWMn3faZhkR0hhBwhJM9zSmlegOkAALZta5qmKApCSC/ACCuVylLsui63k2K/b7VagiD0er1ms9nh+Xqj0W63O50O89zbnG9R8Jkq2SdPtDcH+LKyTW7q+5tplrHD3ETw9Hh08hr/aNAyudHc6pyv+TINbOMcqZ9JDOgm+Q/ONGPR0c/G1bu9j3c0/l55n/9ojuaOIFX641Pb6d0Q/N1c7oP+KVCa0qHVe2u+PALPzqwPKUlZdTv0bc7xPPJc3wntUdAderziT3zXS0i835ndkyR6EP0SATSs6+thIEnKS3CEbBzF+c47l8LhNHjY1h9cCBXFK58my7JVtp5fclgJ3a/1303weiXZDWcnDL9JsNYfjU0rTRbXB5mnqYD9uigPdHO1TK+cAzcMprE0UG00XYQLMIC+GTo2hmNdn9iRt6A5TeMVVl1DMpckMTRL7MPYX5rI5sSWUX0KPh2I/arZfe9UHo++vkJq1zt/ASqPBt+PUZ6vhlVcO9Qun1uWHIp1fHFo/DwKul9kzjF9T0kxSDwz8g3CCIbxzCMOiF2YYJUNRQOLYHnhTAiJ0nBKGAnUlQZMbjQWNKQomqyoUFGBoq0/qBSx4EAGV3m41kBVRqbGd/jfvRu1ZxtQeRIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Network이미지\"\n        title=\"\"\n        src=\"/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/0b533/domtree.png\"\n        srcset=\"/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/fac75/domtree.png 125w,\n/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/63868/domtree.png 250w,\n/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/0b533/domtree.png 500w,\n/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/1d69c/domtree.png 750w,\n/neekoblog/static/b54eca6fd5bf84887fb2b0884fc15095/612f7/domtree.png 773w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>DOM이란?</h3>\n<p><strong>Document Object Model</strong></p>\n<p>HTML, XML 문서의 프로그래밍 interface다.<br>\nDOM의 element는 object로 구성되어있다.</p>\n<p><em>interface란?</em>\n<em>사용자가 상호작용 할 수 있게 하는 프로그래밍 인터페이스이다.</em></p>\n<p>즉, DOM은 동적 콘텐츠를 제공하며 사용자로 하여금 상호작용할 수 있게 한다.</p>\n<p>DOM이 있기 때문에 javascript와 같은 script언어로 문서의 구조, 스타일 등을 조작할 수 있다.</p>\n<p>DOM중에서 최상위에 있는 Document object는 document(웹페이지) 그 자체이다.<br>\npage content는 DOM에 저장되는데 이걸 script언어로 조작할 수 있다.</p>\n<p>DOM API는 DOM을 script 언어로 조작할 수 있도록 제공되는 일련의 인터페이스이다.<br>\n이것을 이용해서 동적으로 element를 조작할 수 있다.</p>\n<hr>\n<h3>그렇다면 React의 Virtual Dom은 무엇인가?</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/bc514/Dom.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRloAAABXRUJQVlA4IE4AAAAQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJaQAAetFIHAAA/vFBZnfxO7A6e8LQjz+ZjrRKgNBiydWOH2Sfv9yAgxNETQPllnhbPpuAAAA='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Network이미지\"\n        title=\"\"\n        src=\"/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/b0a15/Dom.webp\"\n        srcset=\"/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/42aaf/Dom.webp 125w,\n/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/1e0be/Dom.webp 250w,\n/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/b0a15/Dom.webp 500w,\n/neekoblog/static/d897e53bf29dc643e62a1d8811d2ea22/bc514/Dom.webp 720w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Virtual Dom은 <strong>DOM 복사본</strong>이다.<br>\n이는 실제 DOM이 아닌 JS 객체 형태로 메모리에 저장된다.</p>\n<p>VDOM을 통해서 실제 DOM에는 접근할 수 없다. (VDOM을 수정해서 업데이트 한다.)<br>\nVDOM을 수정하는 것은 메모리에 저장되어있는 JS 객체를 수정하는 것이기 때문에 비교적 가볍다.</p>\n<p>VDOM없이 DOM을 조작할 때 스타일을 추가하거나 하면</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#title\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">\"red\"</span></code></pre></div>\n<ol>\n<li>document에서 해당 element를 탐색해서 찾는다.</li>\n<li>해당 element와 그 자식 element들을 DOM에서 제거한다.</li>\n<li>수정된 Element로 교체한다.</li>\n</ol>\n<p>이 과정에서 브라우저의 Reflow와 Repaint를 유발한다.<br>\n단순히 조금만 수정한다면 문제는 없지만 사이트가 거대해질수록 위의 작업이 반복적으로 일어난다.</p>\n<hr>\n<h3>React는 VDOM을 이용해서 어떻게 효율적으로 랜더링하나?</h3>\n<p>React에서는<br>\n<strong>랜더링 이전 구조를 나타내는 VDOM</strong><br>\n<strong>랜더링 이후에 보일 구조를 나타내는 VDOM</strong>이 존재한다.</p>\n<p>React에서는 State가 변경될 때마다 Re-Rendering이 발생하면서 <strong>랜더링 이후에 보일 구조를 나타내는 VDOM</strong>을 생성한다.<br>\n그러면 React는 이 두개의 VDOM을 비교해서 어떤 Element가 바뀌었는지 비교한다. <strong>(Diffing)</strong><br>\n실제로 바뀐 부분만 실제 DOM에 적용한다. <strong>(Reconciliation)</strong><br>\n변경된 모든 내용을 집단화시켜서 한번에 실제 DOM에 적용하는 과정을 거친다. <strong>(Batch Update)</strong></p>\n<p>따라서 훨씬 효율적인 랜더링을 할 수 있다.</p>\n<p>참고자료 : <a href=\"https://callmedevmomo.medium.com/virtual-dom-react-%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC-bfbfcecc4fbb\">https://callmedevmomo.medium.com/virtual-dom-react-%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC-bfbfcecc4fbb</a></p>\n<p>사진 출처 : <a href=\"https://medium.com/@surksha8/virtual-dom-and-real-dom-understanding-the-differences-da8f3fab4261\">https://medium.com/@surksha8/virtual-dom-and-real-dom-understanding-the-differences-da8f3fab4261</a></p>\n<p><a href=\"https://www.freecodecamp.org/news/introduction-to-the-dom/\">https://www.freecodecamp.org/news/introduction-to-the-dom/</a></p>","frontmatter":{"title":"DOM과 VDOM","date":"September 02, 2024","description":"DOM과 VDOM에 대하여"}},"previous":{"fields":{"slug":"/ssr-server/"},"frontmatter":{"title":"SSR과 CSR의 차이"}},"next":{"fields":{"slug":"/w3cAndWebSustain/"},"frontmatter":{"title":"웹 표준과 웹 호환성"}}},"pageContext":{"id":"e4160bb3-aaaf-55c7-8dc3-2ff55b91ea68","previousPostId":"3342f8e8-116d-5e3f-87a8-e8b2a0410bd3","nextPostId":"26b50efd-6bf0-58e5-8a93-2c33612320f7"}},"staticQueryHashes":["1469588348","2841359383"],"slicesMap":{}}